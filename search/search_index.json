{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"simulateTestCases","text":"<p><code>simulateTestCases</code> is a Python package designed for running a series of ADflow simulations using Mphys and OpenMDAO. This package provides streamlined functions to automate simulation test cases.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Simplifies running multiple simulation cases with ADflow.</li> <li>Integrates with Mphys and OpenMDAO for streamlined data management.</li> <li>Generates comparison plots for experimental conditions in each case.</li> </ul>"},{"location":"additionalInfo/","title":"Additional Information","text":"<ul> <li>For more information on ADflow code vist ADflow Documentation</li> <li>Documentation for MPhys, and the available scenarios can be found at MPhys Documentation</li> <li>Instructions for insalling dependencies can be found at MACH Aero Documentation</li> </ul>"},{"location":"installation/","title":"Installation and Dependencies","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":""},{"location":"installation/#core-framework-dependencies","title":"Core Framework Dependencies","text":"<p>The framework requires tools developed by NASA (OpenMDAO and MPhys) and the MDO Lab (MACH-Aero framework). The MACH-Aero framework houses all the core packages needed to run CFD simulations. Below is the list of software required:</p> <ul> <li><code>OpenMDAO</code></li> <li><code>MPhys</code></li> <li><code>baseClasses</code></li> <li><code>pySpline</code></li> <li><code>pyGeo</code></li> <li><code>IDWarp</code></li> <li><code>ADflow</code></li> <li><code>pyOptSparse</code></li> <li><code>TACS</code> (optional)</li> </ul> <p>These software packages may have additional third-party dependencies like PETSc and OpenMPI. A detailed guide on the additional dependencies required is available here.</p>"},{"location":"installation/#python-libraries","title":"Python Libraries","text":"<p>The following Python libraries are also required:</p> <ul> <li><code>numpy&gt;=1.21</code></li> <li><code>scipy&gt;=1.7</code></li> <li><code>mpi4py&gt;=3.1.4</code></li> <li><code>petsc4py</code></li> <li><code>pyyaml</code></li> <li><code>matplotlib</code></li> <li><code>pandas</code></li> <li><code>pydantic</code></li> </ul>"},{"location":"installation/#getting-started","title":"Getting Started","text":"<p>To begin using this framework, follow these steps:</p> <ol> <li> <p>Create a Directory    Set up a directory on your machine where you want to store this framework along with the necessary software packages.</p> <pre><code>$ mkdir &lt;directory-path&gt; \n$ cd &lt;directory-path&gt;\n</code></pre> </li> <li> <p>Install Dependencies    Follow the Installation of Dependencies section to ensure all required dependencies are installed on your system.</p> </li> <li> <p>Install the Package    Complete the setup by following the steps outlined in the Package Installation section.</p> </li> </ol> <p>By completing these steps, you'll have the framework ready for use.</p>"},{"location":"installation/#installation-of-dependencies","title":"Installation of Dependencies","text":"<p>There are two types of installation methods available - from scratch and through Docker. If you are on a local machine, we recommend using Docker as it is the easiest option. If you are on an HPC machine, only the scratch installation method is available. Singularity support will be added later. Please follow the appropriate link.</p> <ul> <li>Local machine (Docker)</li> <li>Local machine (Scratch)</li> <li>HPC - Great Lakes (Singularity)</li> <li>HPC - Great Lakes (Scratch)</li> </ul>"},{"location":"installation/#local-machine","title":"Local machine","text":""},{"location":"installation/#using-docker-recommended","title":"Using Docker (Recommended)","text":"<p>Docker is highly recommended for ease of installation:</p> <ol> <li> <p>Setup Docker: If you do not have Docker installed in your system, follow the Docker Guide to set it up.</p> </li> <li> <p>Pull a Docker image: Official images for GCC and INTEL compilers are available here. Follow the instructions in the link to pull an image compatible to your systems' architecture.</p> </li> <li> <p>Initialize and start a container, follow the instructions mentioned here to initialize and start a container. Mount the directory <code>&lt;directory-path&gt;</code> into the folder mentioned in here.</p> </li> <li> <p>Inside the container, navigate to the <code>mount</code> directory and clone this repository following the instructions in the Package Installation section.</p> </li> <li> <p>Run the testcase (TBD)</p> </li> </ol> <p>Note: If you are referencing any paths inside the container, they must be with respect to the container's folder architecture, not your host machine.</p>"},{"location":"installation/#from-scratch","title":"From Scratch","text":"<p>To manually install all dependencies, we will refer to the instructions found in the Scratch Installation Guide.</p> <p>(Sanjan needs tio fix the local install bash file, unable to identify issue with petsc. Will do soon.)</p>"},{"location":"installation/#hpc-systems-great-lakes","title":"HPC Systems (Great Lakes)","text":""},{"location":"installation/#singularity","title":"Singularity","text":"<p>TBD</p>"},{"location":"installation/#scratch","title":"Scratch","text":"<p>These instructions assume that you are on the Great Lakes HPC at UMich.</p> <ol> <li> <p>Add the following lines to your <code>~/.bashrc</code> file:     <pre><code># Load required modules\nmodule load gcc              # GNU Compiler\nmodule load openmpi          # MPI Libraries\nmodule load python/3.9.12    # Python 3.9.12\nmodule load cmake            # CMake for build systems\n\n# PETSc Installation\nexport PETSC_ARCH=real-opt\nexport PETSC_DIR=&lt;directory-path&gt;/packages/petsc-3.15.3\n\n# CGNS Installation\nexport CGNS_HOME=&lt;directory-path&gt;/packages/CGNS-4.4.0/opt-gfortran\nexport PATH=$PATH:$CGNS_HOME/bin\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CGNS_HOME/lib\n</code></pre>     Replace <code>&lt;directory-path&gt;</code> with your installation directory path. Do not forget to <code>source ~/.bashrc</code> after editing.</p> </li> <li> <p>Clone the repository:     <pre><code>$ git clone https://github.com/gorodetsky-umich/simulateTestCases.git\n</code></pre></p> <p>Copy and execute the installation script: <pre><code>$ cd simulateTestCases\n\n$ cp simulateTestCases/install_packages_gl.sh &lt;directory-path&gt;/\n\n$ chmod +x install_packages_gl.sh\n\n$ ./install_packages_gl.sh\n</code></pre></p> </li> <li> <p>Run the testcase (TBD)</p> </li> </ol>"},{"location":"installation/#package-installation","title":"Package Installation","text":"<p>The following steps are common for personal computers and HPC systems:</p> <ol> <li>Clone the repository:     <pre><code>$ git clone https://github.com/gorodetsky-umich/simulateTestCases.git\n</code></pre></li> <li>Navigate into the directory:     <pre><code>$ cd simulateTestCases\n</code></pre></li> <li>Install the package:<ul> <li>Without dependencies:     <pre><code>$ pip install .\n</code></pre></li> <li>With dependencies:     <pre><code>$ pip install . -r requirements.txt\n</code></pre></li> <li>Editable installation:     <pre><code>$ pip install -e .\n</code></pre></li> </ul> </li> </ol>"},{"location":"installation/#verification","title":"Verification","text":"<p>To verify the installation of packages, run a MACH-Aero tutorial available available on the MDO lab website. The files required to run the tutprial can be obtained from the the MACH-Aero github repo.</p> <p>Follow the steps to run a MACH-Aero tutorial:</p> <ol> <li> <p>Clone the MACH-Aero repo <pre><code>$ git clone https://github.com/mdolab/MACH-Aero.git\n</code></pre></p> </li> <li> <p>Create a new directory to run the tutorial <pre><code>$ mkdir &lt;path-to-tutorial-directory&gt;\n$ cd &lt;path-to-tutorial-directory&gt;\n</code></pre></p> </li> <li>Copy the necessary files <pre><code>$ cp &lt;path-to-mach-aero-directory&gt;/tutorial/aero/analysis/wing_vol.cgns .\n$ cp &lt;path-to-mach-aero-directory&gt;/tutorial/aero/analysis/aero_run.py\n</code></pre></li> <li>Run the python file To run using one processor: <pre><code>python aero_run.py\n</code></pre> To run using multiple processors: <pre><code>mpirun -np &lt;nproc&gt; python aero_run.py\n</code></pre> Note: Running using multiple processors helps to identify the problems with <code>openmpi</code> and <code>petsc</code> installations</li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>helpers</li> <li>resources</li> <li>run_sim</li> <li>utils</li> </ul>"},{"location":"reference/helpers/","title":"helpers","text":""},{"location":"reference/helpers/#helpers.check_input_yaml","title":"<code>check_input_yaml(yaml_file)</code>","text":"<p>Validates the structure of the input YAML file against predefined templates.</p> <p>This function checks whether the input YAML file conforms to the expected template structure. It validates each section, including simulation, HPC, hierarchies, cases, and experimental sets.</p>"},{"location":"reference/helpers/#helpers.check_input_yaml--inputs","title":"Inputs","text":"<ul> <li>yaml_file : str     Path to the YAML file to be validated.</li> </ul>"},{"location":"reference/helpers/#helpers.check_input_yaml--outputs","title":"Outputs","text":"<p>ValidationError     If the YAML file does not conform to the expected structure.</p>"},{"location":"reference/helpers/#helpers.check_input_yaml--notes","title":"Notes","text":"<ul> <li>Uses <code>ref_sim_info</code>, <code>ref_hpc_info</code>, and other reference pydantic models listed in <code>yaml_config.py</code> for validation.</li> <li>Ensures hierarchical consistency by iterating through all levels of the YAML structure.</li> </ul> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def check_input_yaml(yaml_file):\n    \"\"\"\n    Validates the structure of the input YAML file against predefined templates.\n\n    This function checks whether the input YAML file conforms to the expected template structure. It validates each section, including simulation, HPC, hierarchies, cases, and experimental sets.\n\n    Inputs\n    ----------\n    - **yaml_file** : str\n        Path to the YAML file to be validated.\n\n    Outputs\n    ------\n    **ValidationError**\n        If the YAML file does not conform to the expected structure.\n\n    Notes\n    -----\n    - Uses `ref_sim_info`, `ref_hpc_info`, and other reference pydantic models listed in `yaml_config.py` for validation.\n    - Ensures hierarchical consistency by iterating through all levels of the YAML structure.\n    \"\"\"\n    with open(yaml_file, 'r') as file:\n        sim_info = yaml.safe_load(file)\n\n    ref_sim_info.model_validate(sim_info)\n    if sim_info['run_as_subprocess']=='yes':\n        if 'nproc' not in sim_info or not isinstance(sim_info['nproc'], int):\n            raise ValueError(\"'nproc' must be provided as an integer when 'run_as_subprocess' is 'yes'\")\n    if sim_info['hpc'] == 'yes':\n        ref_hpc_info.model_validate(sim_info['hpc_info'])\n    for hierarchy, hierarchy_info in enumerate(sim_info['hierarchies']): # loop for Hierarchy level\n        ref_hierarchy_info.model_validate(hierarchy_info)\n        for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n            ref_case_info.model_validate(case_info)\n            ref_geometry_info.model_validate(case_info['geometry_info'])\n            for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n                ref_exp_set_info.model_validate(exp_info)\n</code></pre>"},{"location":"reference/helpers/#helpers.load_csv_data","title":"<code>load_csv_data(csv_file, comm)</code>","text":"<p>Loads a CSV file and returns its content as a Pandas DataFrame.</p> <p>This function reads the specified CSV file and converts its content into a Pandas DataFrame. It handles common errors such as missing files, empty files, or parsing issues.</p>"},{"location":"reference/helpers/#helpers.load_csv_data--inputs","title":"Inputs","text":"<ul> <li>csv_file : str     Path to the CSV file to be loaded.</li> </ul>"},{"location":"reference/helpers/#helpers.load_csv_data--outputs","title":"Outputs","text":"<p>pandas.DataFrame or None     A DataFrame containing the content of the CSV file if successful, or None if an error occurs.</p> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def load_csv_data(csv_file, comm):\n    \"\"\"\n    Loads a CSV file and returns its content as a Pandas DataFrame.\n\n    This function reads the specified CSV file and converts its content into a Pandas DataFrame. It handles common errors such as missing files, empty files, or parsing issues.\n\n    Inputs\n    ----------\n    - **csv_file** : str\n        Path to the CSV file to be loaded.\n\n    Outputs\n    -------\n    **pandas.DataFrame or None**\n        A DataFrame containing the content of the CSV file if successful, or None if an error occurs.\n\"\"\"\n    try:\n        df = pd.read_csv(csv_file)\n        return df\n    except FileNotFoundError:\n        if comm.rank == 0:\n            print(f\"Warning: The file '{csv_file}' was not found. Please check the file path.\")\n    except pd.errors.EmptyDataError:\n        if comm.rank == 0:\n            print(\"Error: The file is empty. Please check if data has been written correctly.\")\n    except pd.errors.ParserError:\n        if comm.rank == 0:\n            print(\"Error: The file could not be parsed. Please check the file format.\")\n    except Exception as e:\n        if comm.rank == 0:\n            print(f\"An unexpected error occurred: {e}\")\n    return None # In case of error, return none.\n</code></pre>"},{"location":"reference/helpers/#helpers.load_yaml_file","title":"<code>load_yaml_file(yaml_file, comm)</code>","text":"<p>Loads a YAML file and returns its content as a dictionary.</p> <p>This function attempts to read the specified YAML file and parse its content into a Python dictionary. If the file cannot be loaded due to errors, it provides a detailed error message.</p>"},{"location":"reference/helpers/#helpers.load_yaml_file--inputs","title":"Inputs","text":"<ul> <li>yaml_file : str     Path to the YAML file to be loaded.</li> </ul>"},{"location":"reference/helpers/#helpers.load_yaml_file--outputs","title":"Outputs","text":"<p>dict or None     A dictionary containing the content of the YAML file if successful, or None if an error occurs.</p> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def load_yaml_file(yaml_file, comm):\n    \"\"\"\n    Loads a YAML file and returns its content as a dictionary.\n\n    This function attempts to read the specified YAML file and parse its content into a Python dictionary. If the file cannot be loaded due to errors, it provides a detailed error message.\n\n    Inputs\n    ----------\n    - **yaml_file** : str\n        Path to the YAML file to be loaded.\n\n    Outputs\n    -------\n    **dict or None**\n        A dictionary containing the content of the YAML file if successful, or None if an error occurs.\n    \"\"\"\n    try:\n        # Attempt to open and read the YAML file\n        with open(yaml_file, 'r') as file:\n            dict_info = yaml.safe_load(file)\n        return dict_info\n    except FileNotFoundError:\n        # Handle the case where the YAML file is not found\n        if comm.rank == 0:  # Only the root process prints this error\n            print(f\"FileNotFoundError: The info file '{yaml_file}' was not found.\")\n    except yaml.YAMLError as ye:\n        # Errors in YAML parsing\n        if comm.rank == 0:  # Only the root process prints this error\n            print(f\"YAMLError: There was an issue reading '{yaml_file}'. Check the YAML formatting. Error: {ye}\")\n    except Exception as e:\n        # General error catch in case of other unexpected errors\n        if comm.rank == 0:  # Only the root process prints this error\n            print(f\"An unexpected error occurred while loading the info file: {e}\")\n    return None\n</code></pre>"},{"location":"reference/helpers/#helpers.run_as_subprocess","title":"<code>run_as_subprocess(sim_info, hierarchy_info, case_info, exp_info, aoa, aoa_out_dir, nproc, comm)</code>","text":"<p>Executes a simulation case as a subprocess using mpirun.</p> <p>This function automates the creation of input files, ensures directories exist, and runs a subprocess to execute simulations in parallel.</p>"},{"location":"reference/helpers/#helpers.run_as_subprocess--inputs","title":"Inputs","text":"<ul> <li>sim_info : dict     Dictionary containing simulation details, such as output directory, job name, and other metadata.</li> <li>hierarchy_info : dict     Information about the simulation hierarchy, including hierarchy name.</li> <li>case_info : dict     Details about the simulation case, such as mesh files, geometry, and solver parameters.</li> <li>exp_info : dict     Experimental setup details, including Reynolds number, Mach number, temperature, and experimental data.</li> <li>aoa : float     The angle of attack (in degrees) for the simulation.</li> <li>aoa_out_dir : str     Directory where output specific to the given angle of attack will be stored.</li> <li>nproc : int     Number of processors to use for the subprocess execution.</li> <li>comm : MPI communicator     An MPI communicator object to handle parallelism.</li> </ul>"},{"location":"reference/helpers/#helpers.run_as_subprocess--outputs","title":"Outputs","text":"<ul> <li>None     This function does not return any value but performs the following actions:<ol> <li>Creates necessary directories and input files.</li> <li>Launches a subprocess to execute the simulation using <code>mpirun</code>.</li> <li>Prints standard output and error logs from the subprocess for debugging.</li> </ol> </li> </ul>"},{"location":"reference/helpers/#helpers.run_as_subprocess--notes","title":"Notes","text":"<ul> <li>The function ensures the proper setup of the simulation environment for the given angle of attack.</li> <li>The generated Python script and YAML input file are specific to each simulation run.</li> <li>Uses MPI to parallelize the simulation process.</li> <li>Captures and displays <code>stdout</code> and <code>stderr</code> from the subprocess for troubleshooting.</li> </ul> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def run_as_subprocess(sim_info, hierarchy_info, case_info, exp_info, aoa, aoa_out_dir, nproc, comm):\n    \"\"\"\n    Executes a simulation case as a subprocess using mpirun.\n\n    This function automates the creation of input files, ensures directories exist, and runs a subprocess to execute simulations in parallel.\n\n    Inputs\n    ------\n    - **sim_info** : dict  \n        Dictionary containing simulation details, such as output directory, job name, and other metadata.\n    - **hierarchy_info** : dict  \n        Information about the simulation hierarchy, including hierarchy name.\n    - **case_info** : dict  \n        Details about the simulation case, such as mesh files, geometry, and solver parameters.\n    - **exp_info** : dict  \n        Experimental setup details, including Reynolds number, Mach number, temperature, and experimental data.\n    - **aoa** : float  \n        The angle of attack (in degrees) for the simulation.\n    - **aoa_out_dir** : str  \n        Directory where output specific to the given angle of attack will be stored.\n    - **nproc** : int  \n        Number of processors to use for the subprocess execution.\n    - **comm** : MPI communicator  \n        An MPI communicator object to handle parallelism.\n\n    Outputs\n    -------\n    - **None**  \n        This function does not return any value but performs the following actions:\n        1. Creates necessary directories and input files.\n        2. Launches a subprocess to execute the simulation using `mpirun`.\n        3. Prints standard output and error logs from the subprocess for debugging.\n\n    Notes\n    -----\n    - The function ensures the proper setup of the simulation environment for the given angle of attack.\n    - The generated Python script and YAML input file are specific to each simulation run.\n    - Uses MPI to parallelize the simulation process.\n    - Captures and displays `stdout` and `stderr` from the subprocess for troubleshooting.\n    \"\"\"\n    aoa_specific_sim_info = {\n        'out_dir': sim_info['out_dir'],\n        'hpc': 'no',\n        'run_as_subprocess': 'no',\n        'hierarchies':[\n            {\n                'name': hierarchy_info['name'],\n                'cases':[\n                    {\n                        'name': case_info['name'],\n                        'meshes_folder_path': case_info['meshes_folder_path'],\n                        'mesh_files': case_info['mesh_files'],\n                        'geometry_info': case_info['geometry_info'],\n                        'solver_parameters': case_info['solver_parameters'],\n                        'exp_sets':[\n                            {\n                                'aoa_list': [aoa],\n                                'Re': exp_info['Re'],\n                                'mach': exp_info['mach'],\n                                'Temp': exp_info['Temp'],\n                                'exp_data': exp_info['exp_data'],\n                            },\n                        ],\n                    },\n                ],\n            },\n        ],\n    }\n    if not os.path.exists(aoa_out_dir): # Create the directory if it doesn't exist\n        if comm.rank == 0:\n            os.makedirs(aoa_out_dir)\n\n    aoa_specific_input_file = f\"{aoa_out_dir}/temp_input_file.yaml\"\n    if comm.rank==0:\n        with open(aoa_specific_input_file, 'w') as input_file:\n            yaml.dump(aoa_specific_sim_info, input_file, sort_keys=False)\n\n    python_fname = f\"{sim_info['out_dir']}/script_for_subprocess.py\"\n\n    if not os.path.exists(python_fname):\n        if comm.rank==0:\n            write_python_file(python_fname)\n\n    env = os.environ.copy()\n    if comm.rank==0:\n        print(f\"{'-' * 30}\")\n        print(f\"Starting subprocess for aoa: {aoa}\")\n        if sim_info['hpc'] != 'yes':\n            p = subprocess.Popen(\n                ['mpirun', '-np', str(nproc), 'python', python_fname, '--inputFile', aoa_specific_input_file],\n                env=env,\n                stdout=subprocess.PIPE,  # Capture standard output\n                stderr=subprocess.PIPE,  # Capture standard error\n                text=True  # Ensure output is in text format, not bytes\n                )\n        elif sim_info['hpc'] == 'yes':\n            p = subprocess.Popen(\n                ['srun', '-n', str(nproc), 'python', python_fname, '--inputFile', aoa_specific_input_file],\n                env=env,\n                stdout=subprocess.PIPE,  # Capture standard output\n                stderr=subprocess.PIPE,  # Capture standard error\n                text=True  # Ensure output is in text format, not bytes\n                )\n        # Read and print the output and error messages\n        stdout, stderr = p.communicate()\n\n        #print(\"Subprocess Output:\", stdout)\n        #print(\"Subprocess Error:\", stderr)\n\n        p.wait() # Wait for subprocess to end\n\n        print(f\"Completed\")\n        print(f\"{'-' * 30}\")\n\n    # Delete the files\n    if comm.rank == 0:\n        os.remove(aoa_specific_input_file)\n</code></pre>"},{"location":"reference/helpers/#helpers.write_job_script","title":"<code>write_job_script(sim_info, out_dir, out_file, python_file_path, yaml_file_path)</code>","text":"<p>Generates a job script for running simulations on an HPC cluster.</p> <p>This function reads a Slurm job script template, updates it with specific HPC parameters and file paths, and saves the customized script to the output directory.</p>"},{"location":"reference/helpers/#helpers.write_job_script--inputs","title":"Inputs","text":"<ul> <li>sim_info : dict     Dictionary containing simulation details details.</li> <li>out_dir : str     Directory where the job script and output files will be saved.</li> <li>out_file : str     Name of the file to store job output.</li> <li>python_file_path : str     Path to the Python script to be executed by the job script.</li> <li>yaml_file_path : str     Path to the YAML file containing simulation information.</li> </ul>"},{"location":"reference/helpers/#helpers.write_job_script--outputs","title":"Outputs","text":"<ul> <li>str     Path to the generated job script.</li> </ul>"},{"location":"reference/helpers/#helpers.write_job_script--notes","title":"Notes","text":"<ul> <li>Supports customization for the GL cluster with Slurm job scheduling.</li> <li>Uses regex to update the job script with provided parameters.</li> <li>Ensures that the correct Python and YAML file paths are embedded in the job script.</li> </ul> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def write_job_script(sim_info, out_dir, out_file, python_file_path, yaml_file_path):\n    \"\"\"\n    Generates a job script for running simulations on an HPC cluster.\n\n    This function reads a Slurm job script template, updates it with specific HPC parameters and file paths, and saves the customized script to the output directory.\n\n    Inputs\n    ------\n    - **sim_info** : dict\n        Dictionary containing simulation details details.\n    - **out_dir** : str\n        Directory where the job script and output files will be saved.\n    - **out_file** : str\n        Name of the file to store job output.\n    - **python_file_path** : str\n        Path to the Python script to be executed by the job script.\n    - **yaml_file_path** : str\n        Path to the YAML file containing simulation information.\n\n    Outputs\n    -------\n    - **str**\n        Path to the generated job script.\n\n    Notes\n    -----\n    - Supports customization for the GL cluster with Slurm job scheduling.\n    - Uses regex to update the job script with provided parameters.\n    - Ensures that the correct Python and YAML file paths are embedded in the job script.\n    \"\"\"\n    hpc_info = sim_info['hpc_info']\n    if hpc_info['cluster'] == 'GL':\n        # Set default time if not provided\n        job_time = hpc_info.get('time', '1:00:00')\n        mem_per_cpu = hpc_info.get('mem_per_cpu', '1000m')\n\n        # Fill in the template with values from hpc_info and other parameters\n        job_script = gl_job_script.format(\n            job_name=hpc_info['job_name'],\n            nodes=hpc_info['nodes'],\n            nproc=hpc_info['nproc'],\n            mem_per_cpu=mem_per_cpu,\n            time=job_time,\n            account_name=hpc_info['account_name'],\n            email_id=hpc_info['email_id'],\n            out_dir=out_dir,\n            out_file=out_file,\n            python_file_path=python_file_path,\n            yaml_file_path=yaml_file_path\n        )\n\n        # Change 'srun python' command to just python command\n        if sim_info['run_as_subprocess'] == 'yes':\n            job_script = job_script.replace(\"srun python\", \"python\")\n\n        # Define the path for the job script\n        job_script_path = f\"{out_dir}/{hpc_info['job_name']}.sh\"\n\n        # Save the script to the specified file\n        with open(job_script_path, \"w\") as file:\n            file.write(job_script)\n\n        return job_script_path\n</code></pre>"},{"location":"reference/helpers/#helpers.write_python_file","title":"<code>write_python_file(fname)</code>","text":"<p>Generates a Python script to run simulations on an HPC cluster.</p> <p>This function creates a Python script with predefined code to run simulations, including problem setup, execution, and post-processing.</p>"},{"location":"reference/helpers/#helpers.write_python_file--inputs","title":"Inputs","text":"<ul> <li>fname : str     Path where the Python script should be saved.</li> </ul>"},{"location":"reference/helpers/#helpers.write_python_file--notes","title":"Notes","text":"<ul> <li>The generated script uses argparse to accept input YAML files.</li> <li>It imports the <code>run_sim</code> class and runs the simulation using <code>run_problem</code> method.</li> </ul> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def write_python_file(fname):\n    \"\"\"\n    Generates a Python script to run simulations on an HPC cluster.\n\n    This function creates a Python script with predefined code to run simulations, including problem setup, execution, and post-processing.\n\n    Inputs\n    ----------\n    - **fname** : str\n        Path where the Python script should be saved.\n\n    Notes\n    -----\n    - The generated script uses argparse to accept input YAML files.\n    - It imports the `run_sim` class and runs the simulation using `run_problem` method.\n    \"\"\"\n    python_code = \"\"\"\nimport argparse\nfrom simulateTestCases.run_sim import run_sim\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--inputFile\", type=str)\nargs = parser.parse_args()\nsim = run_sim(args.inputFile) # Input the simulation info and output dir\nsim.run_problem() # Run the simulation\n        \"\"\"\n    # Open the file in write mode\n    with open(fname, \"w\") as file:\n        file.write(python_code)\n</code></pre>"},{"location":"reference/run_sim/","title":"run_sim","text":""},{"location":"reference/run_sim/#run_sim.Top","title":"<code>Top</code>","text":"<p>               Bases: <code>Multipoint</code></p> <p>Sets up an OpenMDAO problem using MPhys and ADflow for aerodynamic simulations.</p> <p>This class is designed to integrate OpenMDAO with MPhys and ADflow to perform aerodynamic simulations. It sets up the problem environment, manages inputs and outputs, and configures scenarios for simulation.</p>"},{"location":"reference/run_sim/#run_sim.Top--methods","title":"Methods","text":"<p>setup()     Initializes and sets up the required subsystems and scenarios.</p> <p>configure()     Configures the aerodynamic problem (e.g., reference area, chord, angle of attack) and connects design variables to the system.</p>"},{"location":"reference/run_sim/#run_sim.Top--inputs","title":"Inputs","text":"<ul> <li>case_info : dict     Dictionary containing geometry and configuration details for the case being analyzed.</li> <li>exp_info : dict     Dictionary with experimental conditions such as Mach number, Reynolds number, and temperature.</li> <li>aero_options : dict     ADflow solver parameters that control aerodynamic analysis.</li> </ul>"},{"location":"reference/run_sim/#run_sim.Top--outputs","title":"Outputs","text":"<p>None. This class directly modifies the OpenMDAO problem structure to include aerodynamic analysis subsystems.</p> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>class Top(Multipoint):\n\n    \"\"\"\n    Sets up an OpenMDAO problem using MPhys and ADflow for aerodynamic simulations.\n\n    This class is designed to integrate OpenMDAO with MPhys and ADflow to perform aerodynamic simulations. It sets up the problem environment, manages inputs and outputs, and configures scenarios for simulation.\n\n    Methods\n    --------\n    **setup()**\n        Initializes and sets up the required subsystems and scenarios.\n\n    **configure()**\n        Configures the aerodynamic problem (e.g., reference area, chord, angle of attack) and connects design variables to the system.\n\n    Inputs\n    -------\n    - **case_info** : dict\n        Dictionary containing geometry and configuration details for the case being analyzed.\n    - **exp_info** : dict\n        Dictionary with experimental conditions such as Mach number, Reynolds number, and temperature.\n    - **aero_options** : dict\n        ADflow solver parameters that control aerodynamic analysis.\n\n    Outputs\n    --------\n    None. This class directly modifies the OpenMDAO problem structure to include aerodynamic analysis subsystems.\n\n    \"\"\"\n\n    def __init__(self, case_info, exp_info, aero_options):\n        super().__init__()\n        self.case_info = case_info\n        self.exp_info = exp_info\n        self.aero_options = aero_options\n\n    def setup(self):\n\n        adflow_builder = ADflowBuilder(self.aero_options, scenario=\"aerodynamic\")\n        adflow_builder.initialize(self.comm)\n        adflow_builder.err_on_convergence_fail = True\n\n        ################################################################################\n        # MPHY setup\n        ################################################################################\n\n        # ivc to keep the top level DVs\n        self.add_subsystem(\"dvs\", om.IndepVarComp(), promotes=[\"*\"])\n\n        # create the mesh and cruise scenario because we only have one analysis point\n        self.add_subsystem(\"mesh\", adflow_builder.get_mesh_coordinate_subsystem())\n        self.mphys_add_scenario(\"cruise\", ScenarioAerodynamic(aero_builder=adflow_builder))\n        self.connect(\"mesh.x_aero0\", \"cruise.x_aero\")\n\n    def configure(self):\n        aoa = 0.0 # Set default Angle of attack\n\n        geometry_info = self.case_info['geometry_info'] # Load geometry info\n        chordRef = geometry_info['chordRef']\n        areaRef = geometry_info['areaRef']\n\n        ap0 = AeroProblem(\n            name=\"ap0\",\n            # Experimental Conditions \n            mach = self.exp_info['mach'], reynolds=self.exp_info['Re'], reynoldsLength=chordRef, T=self.exp_info['Temp'], \n            alpha=aoa,\n            # Geometry Info\n            areaRef=areaRef, \n            chordRef=chordRef, \n            evalFuncs=[\"cl\", \"cd\"]\n        )\n        ap0.addDV(\"alpha\", value=aoa, name=\"aoa\", units=\"deg\")\n\n\n        # set the aero problem in the coupling and post coupling groups\n        self.cruise.coupling.mphys_set_ap(ap0)\n        self.cruise.aero_post.mphys_set_ap(ap0)\n\n        # add dvs to ivc and connect\n        self.dvs.add_output(\"aoa\", val=aoa, units=\"deg\")\n        self.connect(\"aoa\", [\"cruise.coupling.aoa\", \"cruise.aero_post.aoa\"])\n</code></pre>"},{"location":"reference/run_sim/#run_sim.run_sim","title":"<code>run_sim</code>","text":"<p>Executes ADflow simulations using the <code>Top</code> class.</p> <p>This class sets up, runs, and post-processes aerodynamic simulations based on input parameters provided via a YAML configuration file. It validates the input, manages directories, and handles outputs, including plots and summary files.</p>"},{"location":"reference/run_sim/#run_sim.run_sim--methods","title":"Methods","text":"<p>run_problem()     Sets up and runs the OpenMDAO problem for all cases, hierarchies, and refinement levels.</p> <p>run()     Executes the simulation on either a local machine or an HPC system.</p> <p>post_process()     Generates plots comparing experimental data (if available) with ADflow simulation results.</p>"},{"location":"reference/run_sim/#run_sim.run_sim--inputs","title":"Inputs","text":"<ul> <li>info_file : str     Path to the YAML file containing simulation configuration and information.</li> </ul> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>class run_sim():\n    \"\"\"\n    Executes ADflow simulations using the `Top` class.\n\n    This class sets up, runs, and post-processes aerodynamic simulations based on input parameters provided via a YAML configuration file. It validates the input, manages directories, and handles outputs, including plots and summary files.\n\n    Methods\n    -------\n    **run_problem()**\n        Sets up and runs the OpenMDAO problem for all cases, hierarchies, and refinement levels.\n\n    **run()**\n        Executes the simulation on either a local machine or an HPC system.\n\n    **post_process()**\n        Generates plots comparing experimental data (if available) with ADflow simulation results.\n\n    Inputs\n    ----------\n    - **info_file** : str\n        Path to the YAML file containing simulation configuration and information.\n    \"\"\"\n\n    def __init__(self, info_file):\n        # Validate the input yaml file\n        check_input_yaml(info_file)\n        if comm.rank == 0:\n            print(f\"{'-' * 50}\")\n            print(\"YAML file validation is successful\")\n            print(f\"{'-' * 50}\")\n\n        self.info_file = info_file\n        self.sim_info = load_yaml_file(self.info_file, comm)\n        self.out_dir = self.sim_info['out_dir']\n        self.final_out_file = f\"{self.out_dir}/overall_sim_info.yaml\" # Setting the overall simulation info file.\n\n\n        # Create the output directory if it doesn't exist\n        if not os.path.exists(self.out_dir): \n            if comm.rank == 0:\n                os.makedirs(self.out_dir)\n\n    ################################################################################\n    # Code for running simulations\n    ################################################################################   \n    def run_problem(self):\n        \"\"\"\n        Sets up and runs the OpenMDAO problem for aerodynamic simulations.\n\n        This method iterates through all hierarchies, cases, refinement levels, and angles of attack defined in the input YAML file. For each combination, it sets up the OpenMDAO problem, runs the simulation, and stores the results.\n\n        Outputs\n        -------\n        - **A CSV file**:\n            Contains results for each angle of attack at the current refinement level.\n        - **A YAML file**:\n            Stores simulation data for each angle of attack in the corresponding directory.\n        - **A final YAML file**:\n            Summarizes all simulation results across hierarchies, cases, and refinement levels.\n\n        Notes\n        -----\n        This method ensures that:\n\n        - Existing successful simulations are skipped.\n        - Directories are created dynamically if they do not exist.\n        - Simulation results are saved in structured output files.\n        \"\"\"\n\n        # Store a copy of input YAML file in output directory\n        input_yaml_file = f\"{self.out_dir}/input_file.yaml\"\n        if comm.rank == 0:\n            with open(input_yaml_file, 'w') as input_yaml_handle:\n                yaml.dump(self.sim_info, input_yaml_handle, sort_keys=False)\n\n        sim_info_copy = copy.deepcopy(self.sim_info) # Copying to run the loop\n        sim_out_info = copy.deepcopy(self.sim_info) # Copying to write the output YAML file\n        start_time = time.time()\n        start_wall_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n        for hierarchy, hierarchy_info in enumerate(sim_info_copy['hierarchies']): # loop for Hierarchy level\n\n            for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n\n                aero_options = default_aero_options.copy()\n                aero_options.update(case_info['solver_parameters']) # Update ADflow solver parameters\n\n                for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n\n                    if comm.rank == 0:\n                        print(f\"{'#' * 30}\")\n                        print(f\"{'SIMULATION INFO':^30}\")\n                        print(f\"{'#' * 30}\")\n                        print(f\"{'Hierarchy':&lt;20}: {hierarchy_info['name']}\")\n                        print(f\"{'Case Name':&lt;20}: {case_info['name']}\")\n                        print(f\"{'Experimental Condition':&lt;20}: {exp_set}\")\n                        print(f\"{'Reynolds Number (Re)':&lt;20}: {exp_info['Re']}\")\n                        print(f\"{'Mach Number':&lt;20}: {exp_info['mach']}\")\n                        print(f\"{'=' * 30}\")\n\n                    # Extract the Angle of attacks for which the simulation has to be run\n                    aoa_list = exp_info['aoa_list']\n\n                    exp_sim_info = {} # Creating experimental level sim info dictionary for overall sim info file\n\n                    for ii, mesh_file in enumerate(case_info['mesh_files']): # Loop for refinement levels\n\n                        refinement_level = f\"L{ii}\"\n                        CLList = []\n                        CDList = []\n                        TList = []\n                        FList = [] # Fail flag list\n\n                        refinement_level_dict = {} # Creating refinement level sim info dictionary for overall sim info file\n\n                        # Update Grid file\n                        aero_options['gridFile'] = f\"{case_info['meshes_folder_path']}/{mesh_file}\"\n\n\n                        for aoa in aoa_list: # loop for angles of attack\n\n                            # Date\n                            current_date = date.today()\n                            date_string = current_date.strftime(\"%Y-%m-%d\")\n\n                            # Define output directory -- Written to store in the parent directory\n                            output_dir = f\"{self.out_dir}/{hierarchy_info['name']}/{case_info['name']}/exp_set_{exp_set}/{refinement_level}/aoa_{aoa}\"\n                            aero_options['outputDirectory'] = output_dir\n\n                            # name of the simulation info file at the aoa level directory\n                            aoa_info_file = f\"{output_dir}/aoa_{aoa}.yaml\" \n\n\n                            aoa_level_dict = {} # Creating aoa level sim info dictionary for overall sim info file\n\n                            # Call 'run_as_subprocess' function if the user has requested\n                            if sim_info_copy['run_as_subprocess'] == 'yes':\n                                run_as_subprocess(sim_info_copy, hierarchy_info, case_info, exp_info, aoa, output_dir, sim_info_copy['nproc'], comm)\n\n                            ################################################################################\n                            # OpenMDAO setup\n                            ################################################################################\n\n                            os.environ[\"OPENMDAO_REPORTS\"]=\"0\" # Do this to disable report generation by OpenMDAO\n\n                            prob = om.Problem()\n                            prob.model = Top(case_info, exp_info, aero_options)\n\n                            # Checking for existing sucessful simualtion info, \n                            if os.path.exists(output_dir):\n                                try:\n                                    with open(aoa_info_file, 'r') as aoa_file:\n                                        aoa_sim_info = yaml.safe_load(aoa_file)\n                                    fail_flag = aoa_sim_info['fail_flag']\n                                    if fail_flag == 0:\n                                        CLList.append(aoa_sim_info['cl'])\n                                        CDList.append(aoa_sim_info['cd'])\n                                        TList.append(float(aoa_sim_info['wall_time'].replace(\" sec\", \"\")))\n                                        FList.append(fail_flag)\n\n                                        # To Store in the overall simulation out file in case of skipping\n                                        aoa_level_dict = {\n                                            'cl': float(aoa_sim_info['cl']),\n                                            'cd': float(aoa_sim_info['cd']),\n                                            'wall_time': aoa_sim_info['wall_time'],\n                                            'fail_flag': int(fail_flag),\n                                            'out_dir': output_dir,\n                                        }\n                                        refinement_level_dict[f\"aoa_{aoa}\"] = aoa_level_dict\n\n                                        if comm.rank == 0:\n                                            print(f\"{'-'*50}\")\n                                            print(f\"{'NOTICE':^50}\")\n                                            print(f\"{'-'*50}\")\n                                            print(f\"Skipping Angle of Attack (AoA): {float(aoa):&lt;5} | Reason: Existing successful simulation found\")\n                                            print(f\"{'-'*50}\")\n                                        continue # Continue to next loop if there exists a successful simulation\n                                except:\n                                    fail_flag = 1\n                            elif not os.path.exists(output_dir): # Create the directory if it doesn't exist\n                                if comm.rank == 0:\n                                    os.makedirs(output_dir)\n\n\n                            if comm.rank == 0:\n                                print(f\"{'-'*50}\")\n                                print(f\"Starting Angle of Attack (AoA): {float(aoa):&lt;5}\")\n                                print(f\"{'-'*50}\")\n                            # Setup the problem\n                            prob.setup()\n\n                            # Set the angle\n                            prob[\"aoa\"] = float(aoa)\n\n                            om.n2(prob, show_browser=False, outfile=f\"{output_dir}/mphys_aero.html\")\n\n                            # Run the model\n                            aoa_start_time = time.time() # Stote the start time\n                            try:\n                                prob.run_model()\n                                fail_flag = 0\n                            except:\n                                fail_flag = 1\n\n                            aoa_end_time = time.time() # Store the end time\n                            aoa_run_time = aoa_end_time - aoa_start_time # Compute the run time\n\n                            prob.model.list_inputs(units=True)\n                            prob.model.list_outputs(units=True)\n\n                            # Store a Yaml file at this level\n                            aoa_out_dic = {\n                                'case': case_info['name'],\n                                'exp_info': exp_info,\n                                'mesh_file_used': f\"{case_info['meshes_folder_path']}/{mesh_file}\",\n                                'AOA': float(aoa),\n                                'cl': float(prob[\"cruise.aero_post.cl\"][0]),\n                                'cd': float(prob[\"cruise.aero_post.cd\"][0]),\n                                'refinement_level': refinement_level,\n                                'wall_time': f\"{aoa_run_time:.2f} sec\",\n                                'fail_flag': int(fail_flag),\n                                'out_dir': output_dir,\n                            }\n                            with open(aoa_info_file, 'w') as interim_out_yaml:\n                                yaml.dump(aoa_out_dic, interim_out_yaml, sort_keys=False)\n\n                            # To Store in the overall simulation out file\n                            aoa_level_dict = {\n                                'cl': float(prob[\"cruise.aero_post.cl\"][0]),\n                                'cd': float(prob[\"cruise.aero_post.cd\"][0]),\n                                'wall_time': f\"{aoa_run_time:.2f} sec\",\n                                'fail_flag': int(fail_flag),\n                                'out_dir': output_dir,\n                            }\n                            refinement_level_dict[f\"aoa_{aoa}\"] = aoa_level_dict\n\n                            # Adding cl, cd, wall time, Fail flags to their respective lists to create the csv file at refinement level\n                            CLList.append(float(prob[\"cruise.aero_post.cl\"][0]))\n                            CDList.append(float(prob[\"cruise.aero_post.cd\"][0]))\n                            TList.append(aoa_run_time)\n                            FList.append(fail_flag)\n\n\n                        # Write simulation results to a csv file\n                        refinement_level_data = {\n                            \"Alpha\": [f\"{alpha:6.2f}\" for alpha in aoa_list],\n                            \"CL\": [f\"{cl:8.4f}\" for cl in CLList],\n                            \"CD\": [f\"{cd:8.4f}\" for cd in CDList],\n                            \"FFlag\": [f\"{int(FF):12f}\" for FF in FList],\n                            \"WTime\": [f\"{wall_time:10.2f}\" for wall_time in TList]\n                        }\n\n                        # Define the output file path\n                        refinement_level_dir = os.path.dirname(output_dir)\n                        ADflow_out_file = f\"{refinement_level_dir}/ADflow_output.csv\"\n\n                        df = pd.DataFrame(refinement_level_data) # Create a panda DataFrame\n                        # Write the DataFrame to a CSV file\n                        df.to_csv(ADflow_out_file, index=False)\n\n                        # Add csv file location to the overall simulation out file\n                        refinement_level_dict['csv_file'] = ADflow_out_file\n                        refinement_level_dict['refinement_out_dir'] = refinement_level_dir\n\n                        # Add refinement level dict to exp level dict\n                        exp_sim_info[f\"{refinement_level}\"] = refinement_level_dict\n\n                    # Add experimental level simulation to the overall simulation out file\n                    exp_out_dir = os.path.dirname(refinement_level_dir)\n                    exp_sim_info['exp_set_out_dir'] = exp_out_dir\n                    sim_out_info['hierarchies'][hierarchy]['cases'][case]['exp_sets'][exp_set]['sim_info'] = exp_sim_info\n\n        end_time = time.time()\n        end_wall_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        net_run_time = end_time - start_time\n        sim_out_info['overall_sim_info'] = {\n            'start_time': start_wall_time,\n            'end_time': end_wall_time,\n            'total_wall_time': f\"{net_run_time:.2f} sec\"\n        }\n\n        # Store the final simulation out file.\n        if comm.rank == 0:\n            with open(self.final_out_file, 'w') as final_out_yaml_handle:\n                yaml.dump(sim_out_info, final_out_yaml_handle, sort_keys=False)\n        comm.Barrier()\n\n    ################################################################################\n    # Code for user to run simulations\n    ################################################################################\n    def run(self):\n        \"\"\"\n        Executes the simulation on either a local machine or an HPC system.\n\n        This method checks the simulation settings from the input YAML file. Based on the `hpc` flag, it either runs the simulation locally or generates an HPC job script for execution.\n\n        Notes\n        -----\n        - For local execution (`hpc: no`), it directly calls `run_problem()`.\n        - For HPC execution (`hpc: yes`), it creates a Python file and a job script, then submits the job using `sbatch`.\n        \"\"\"\n        sim_info_copy = copy.deepcopy(self.sim_info)\n        if sim_info_copy['hpc'] == \"no\":\n            self.run_problem()\n        elif sim_info_copy['hpc'] == \"yes\":\n            python_file_path = f\"{self.out_dir}/run_sim.py\"\n            slrum_out_file = f\"overall_sim_out.txt\"\n            # Create a python file to run\n            write_python_file(python_file_path)\n            # Create a job script to run\n            job_script_path = write_job_script(sim_info_copy, self.out_dir, slrum_out_file, python_file_path, self.info_file)\n\n            subprocess.run([\"sbatch\", job_script_path])\n\n    ################################################################################\n    # Code for Post Processing\n    ################################################################################\n\n    def post_process(self):\n        \"\"\"\n        Generates plots comparing experimental data with ADflow simulation results.\n\n        This method creates comparison plots for each experimental condition and refinement level. The plots include `CL` (Lift Coefficient) and `CD` (Drag Coefficient) against the angle of attack (Alpha). Experimental data, if provided, is included in the plots for validation.\n\n        Outputs\n        -------\n        - *PNG plots*:\n            Stored in the experimental condition directory for each hierarchy and case.\n\n        Notes\n        -----\n        - Experimental data is optional. If not provided, only simulation results are plotted.\n        - Plots are saved with clear labels and legends for easy interpretation.\n        \"\"\"\n        sim_out_info = load_yaml_file(self.final_out_file, comm)\n\n        for hierarchy, hierarchy_info in enumerate(sim_out_info['hierarchies']): # loop for Hierarchy level\n            for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n                for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n\n                    # Plot setup\n                    fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n                    fig.suptitle('Comparison between ADflow Simulation and Experimental Data')\n\n                    # Load Experimental Data\n                    try:\n                        exp_data = load_csv_data(exp_info['exp_data'], comm)\n                    except:\n                        if comm.rank == 0:\n                            print(f\"Warning: Experimental data location is not specified or the data is not readable.\")\n                        exp_data = None\n\n                    if exp_data is not None: # Only plot if data loaded successfully\n                        exp_data.columns = exp_data.columns.str.strip()  # Clean column names\n\n                        # Convert to numeric to avoid plotting issues\n                        exp_data['Alpha'] = pd.to_numeric(exp_data['Alpha'], errors='coerce')\n                        exp_data['CL'] = pd.to_numeric(exp_data['CL'], errors='coerce')\n                        exp_data['CD'] = pd.to_numeric(exp_data['CD'], errors='coerce')\n                        exp_data = exp_data.dropna()  # Drop rows with missing data\n\n                        axs[0].plot(exp_data['Alpha'], exp_data['CL'], label='Experimental', color='black', linestyle='--', marker='o')\n                        axs[1].plot(exp_data['Alpha'], exp_data['CD'], label='Experimental', color='black', linestyle='--', marker='o')\n\n                    else:\n                        if comm.rank == 0:\n                            print(\"Continuing to plot without experimental data.\")\n\n                    num_levels = len(case_info['mesh_files'])  # Total refinement levels\n                    colors = cm.viridis(np.linspace(0, 1, num_levels))  # Generate unique colors for each level\n                    # Load Simulated Data\n                    exp_out_dir = exp_info['sim_info']['exp_set_out_dir']\n                    sim_data = {}\n                    for ii, mesh_file in enumerate(case_info['mesh_files']): # Loop for refinement levels\n                        refinement_level_dir = f\"{exp_out_dir}/L{ii}\"\n                        ADflow_out_file = f\"{refinement_level_dir}/ADflow_output.csv\"\n                        sim_data = load_csv_data(ADflow_out_file, comm)\n                        if sim_data is not None:  # Only plot if data loaded successfully\n                            label = f\"L{ii}\"\n                            axs[0].plot(sim_data['Alpha'], sim_data['CL'], label=label, color=colors[ii], linestyle='-', marker='s') # Plot CL vs Alpha for this refinement level\n                            axs[1].plot(sim_data['Alpha'], sim_data['CD'], label=label, color=colors[ii], linestyle='-', marker='s') # Plot CD vs Alpha for this refinement level\n\n                    # Setting titles, labels, and legends\n                    axs[0].set_title('$C_L$ vs Alpha')\n                    axs[0].set_xlabel('Alpha (deg)')\n                    axs[0].set_ylabel('$C_L$')\n                    axs[0].legend()\n                    axs[0].grid(True)\n\n                    axs[1].set_title('$C_D$ vs Alpha')\n                    axs[1].set_xlabel('Alpha (deg)')\n                    axs[1].set_ylabel('$C_D$')\n                    axs[1].legend()\n                    axs[1].grid(True)\n\n                    plt.tight_layout(rect=[0, 0, 1, 0.96])  # Adjust layout to fit title\n                    plt.savefig(f\"{exp_out_dir}/ADflow_Results.png\")\n</code></pre>"},{"location":"reference/run_sim/#run_sim.run_sim.post_process","title":"<code>post_process()</code>","text":"<p>Generates plots comparing experimental data with ADflow simulation results.</p> <p>This method creates comparison plots for each experimental condition and refinement level. The plots include <code>CL</code> (Lift Coefficient) and <code>CD</code> (Drag Coefficient) against the angle of attack (Alpha). Experimental data, if provided, is included in the plots for validation.</p>"},{"location":"reference/run_sim/#run_sim.run_sim.post_process--outputs","title":"Outputs","text":"<ul> <li>PNG plots:     Stored in the experimental condition directory for each hierarchy and case.</li> </ul>"},{"location":"reference/run_sim/#run_sim.run_sim.post_process--notes","title":"Notes","text":"<ul> <li>Experimental data is optional. If not provided, only simulation results are plotted.</li> <li>Plots are saved with clear labels and legends for easy interpretation.</li> </ul> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>def post_process(self):\n    \"\"\"\n    Generates plots comparing experimental data with ADflow simulation results.\n\n    This method creates comparison plots for each experimental condition and refinement level. The plots include `CL` (Lift Coefficient) and `CD` (Drag Coefficient) against the angle of attack (Alpha). Experimental data, if provided, is included in the plots for validation.\n\n    Outputs\n    -------\n    - *PNG plots*:\n        Stored in the experimental condition directory for each hierarchy and case.\n\n    Notes\n    -----\n    - Experimental data is optional. If not provided, only simulation results are plotted.\n    - Plots are saved with clear labels and legends for easy interpretation.\n    \"\"\"\n    sim_out_info = load_yaml_file(self.final_out_file, comm)\n\n    for hierarchy, hierarchy_info in enumerate(sim_out_info['hierarchies']): # loop for Hierarchy level\n        for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n            for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n\n                # Plot setup\n                fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n                fig.suptitle('Comparison between ADflow Simulation and Experimental Data')\n\n                # Load Experimental Data\n                try:\n                    exp_data = load_csv_data(exp_info['exp_data'], comm)\n                except:\n                    if comm.rank == 0:\n                        print(f\"Warning: Experimental data location is not specified or the data is not readable.\")\n                    exp_data = None\n\n                if exp_data is not None: # Only plot if data loaded successfully\n                    exp_data.columns = exp_data.columns.str.strip()  # Clean column names\n\n                    # Convert to numeric to avoid plotting issues\n                    exp_data['Alpha'] = pd.to_numeric(exp_data['Alpha'], errors='coerce')\n                    exp_data['CL'] = pd.to_numeric(exp_data['CL'], errors='coerce')\n                    exp_data['CD'] = pd.to_numeric(exp_data['CD'], errors='coerce')\n                    exp_data = exp_data.dropna()  # Drop rows with missing data\n\n                    axs[0].plot(exp_data['Alpha'], exp_data['CL'], label='Experimental', color='black', linestyle='--', marker='o')\n                    axs[1].plot(exp_data['Alpha'], exp_data['CD'], label='Experimental', color='black', linestyle='--', marker='o')\n\n                else:\n                    if comm.rank == 0:\n                        print(\"Continuing to plot without experimental data.\")\n\n                num_levels = len(case_info['mesh_files'])  # Total refinement levels\n                colors = cm.viridis(np.linspace(0, 1, num_levels))  # Generate unique colors for each level\n                # Load Simulated Data\n                exp_out_dir = exp_info['sim_info']['exp_set_out_dir']\n                sim_data = {}\n                for ii, mesh_file in enumerate(case_info['mesh_files']): # Loop for refinement levels\n                    refinement_level_dir = f\"{exp_out_dir}/L{ii}\"\n                    ADflow_out_file = f\"{refinement_level_dir}/ADflow_output.csv\"\n                    sim_data = load_csv_data(ADflow_out_file, comm)\n                    if sim_data is not None:  # Only plot if data loaded successfully\n                        label = f\"L{ii}\"\n                        axs[0].plot(sim_data['Alpha'], sim_data['CL'], label=label, color=colors[ii], linestyle='-', marker='s') # Plot CL vs Alpha for this refinement level\n                        axs[1].plot(sim_data['Alpha'], sim_data['CD'], label=label, color=colors[ii], linestyle='-', marker='s') # Plot CD vs Alpha for this refinement level\n\n                # Setting titles, labels, and legends\n                axs[0].set_title('$C_L$ vs Alpha')\n                axs[0].set_xlabel('Alpha (deg)')\n                axs[0].set_ylabel('$C_L$')\n                axs[0].legend()\n                axs[0].grid(True)\n\n                axs[1].set_title('$C_D$ vs Alpha')\n                axs[1].set_xlabel('Alpha (deg)')\n                axs[1].set_ylabel('$C_D$')\n                axs[1].legend()\n                axs[1].grid(True)\n\n                plt.tight_layout(rect=[0, 0, 1, 0.96])  # Adjust layout to fit title\n                plt.savefig(f\"{exp_out_dir}/ADflow_Results.png\")\n</code></pre>"},{"location":"reference/run_sim/#run_sim.run_sim.run","title":"<code>run()</code>","text":"<p>Executes the simulation on either a local machine or an HPC system.</p> <p>This method checks the simulation settings from the input YAML file. Based on the <code>hpc</code> flag, it either runs the simulation locally or generates an HPC job script for execution.</p>"},{"location":"reference/run_sim/#run_sim.run_sim.run--notes","title":"Notes","text":"<ul> <li>For local execution (<code>hpc: no</code>), it directly calls <code>run_problem()</code>.</li> <li>For HPC execution (<code>hpc: yes</code>), it creates a Python file and a job script, then submits the job using <code>sbatch</code>.</li> </ul> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>def run(self):\n    \"\"\"\n    Executes the simulation on either a local machine or an HPC system.\n\n    This method checks the simulation settings from the input YAML file. Based on the `hpc` flag, it either runs the simulation locally or generates an HPC job script for execution.\n\n    Notes\n    -----\n    - For local execution (`hpc: no`), it directly calls `run_problem()`.\n    - For HPC execution (`hpc: yes`), it creates a Python file and a job script, then submits the job using `sbatch`.\n    \"\"\"\n    sim_info_copy = copy.deepcopy(self.sim_info)\n    if sim_info_copy['hpc'] == \"no\":\n        self.run_problem()\n    elif sim_info_copy['hpc'] == \"yes\":\n        python_file_path = f\"{self.out_dir}/run_sim.py\"\n        slrum_out_file = f\"overall_sim_out.txt\"\n        # Create a python file to run\n        write_python_file(python_file_path)\n        # Create a job script to run\n        job_script_path = write_job_script(sim_info_copy, self.out_dir, slrum_out_file, python_file_path, self.info_file)\n\n        subprocess.run([\"sbatch\", job_script_path])\n</code></pre>"},{"location":"reference/run_sim/#run_sim.run_sim.run_problem","title":"<code>run_problem()</code>","text":"<p>Sets up and runs the OpenMDAO problem for aerodynamic simulations.</p> <p>This method iterates through all hierarchies, cases, refinement levels, and angles of attack defined in the input YAML file. For each combination, it sets up the OpenMDAO problem, runs the simulation, and stores the results.</p>"},{"location":"reference/run_sim/#run_sim.run_sim.run_problem--outputs","title":"Outputs","text":"<ul> <li>A CSV file:     Contains results for each angle of attack at the current refinement level.</li> <li>A YAML file:     Stores simulation data for each angle of attack in the corresponding directory.</li> <li>A final YAML file:     Summarizes all simulation results across hierarchies, cases, and refinement levels.</li> </ul>"},{"location":"reference/run_sim/#run_sim.run_sim.run_problem--notes","title":"Notes","text":"<p>This method ensures that:</p> <ul> <li>Existing successful simulations are skipped.</li> <li>Directories are created dynamically if they do not exist.</li> <li>Simulation results are saved in structured output files.</li> </ul> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>def run_problem(self):\n    \"\"\"\n    Sets up and runs the OpenMDAO problem for aerodynamic simulations.\n\n    This method iterates through all hierarchies, cases, refinement levels, and angles of attack defined in the input YAML file. For each combination, it sets up the OpenMDAO problem, runs the simulation, and stores the results.\n\n    Outputs\n    -------\n    - **A CSV file**:\n        Contains results for each angle of attack at the current refinement level.\n    - **A YAML file**:\n        Stores simulation data for each angle of attack in the corresponding directory.\n    - **A final YAML file**:\n        Summarizes all simulation results across hierarchies, cases, and refinement levels.\n\n    Notes\n    -----\n    This method ensures that:\n\n    - Existing successful simulations are skipped.\n    - Directories are created dynamically if they do not exist.\n    - Simulation results are saved in structured output files.\n    \"\"\"\n\n    # Store a copy of input YAML file in output directory\n    input_yaml_file = f\"{self.out_dir}/input_file.yaml\"\n    if comm.rank == 0:\n        with open(input_yaml_file, 'w') as input_yaml_handle:\n            yaml.dump(self.sim_info, input_yaml_handle, sort_keys=False)\n\n    sim_info_copy = copy.deepcopy(self.sim_info) # Copying to run the loop\n    sim_out_info = copy.deepcopy(self.sim_info) # Copying to write the output YAML file\n    start_time = time.time()\n    start_wall_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    for hierarchy, hierarchy_info in enumerate(sim_info_copy['hierarchies']): # loop for Hierarchy level\n\n        for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n\n            aero_options = default_aero_options.copy()\n            aero_options.update(case_info['solver_parameters']) # Update ADflow solver parameters\n\n            for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n\n                if comm.rank == 0:\n                    print(f\"{'#' * 30}\")\n                    print(f\"{'SIMULATION INFO':^30}\")\n                    print(f\"{'#' * 30}\")\n                    print(f\"{'Hierarchy':&lt;20}: {hierarchy_info['name']}\")\n                    print(f\"{'Case Name':&lt;20}: {case_info['name']}\")\n                    print(f\"{'Experimental Condition':&lt;20}: {exp_set}\")\n                    print(f\"{'Reynolds Number (Re)':&lt;20}: {exp_info['Re']}\")\n                    print(f\"{'Mach Number':&lt;20}: {exp_info['mach']}\")\n                    print(f\"{'=' * 30}\")\n\n                # Extract the Angle of attacks for which the simulation has to be run\n                aoa_list = exp_info['aoa_list']\n\n                exp_sim_info = {} # Creating experimental level sim info dictionary for overall sim info file\n\n                for ii, mesh_file in enumerate(case_info['mesh_files']): # Loop for refinement levels\n\n                    refinement_level = f\"L{ii}\"\n                    CLList = []\n                    CDList = []\n                    TList = []\n                    FList = [] # Fail flag list\n\n                    refinement_level_dict = {} # Creating refinement level sim info dictionary for overall sim info file\n\n                    # Update Grid file\n                    aero_options['gridFile'] = f\"{case_info['meshes_folder_path']}/{mesh_file}\"\n\n\n                    for aoa in aoa_list: # loop for angles of attack\n\n                        # Date\n                        current_date = date.today()\n                        date_string = current_date.strftime(\"%Y-%m-%d\")\n\n                        # Define output directory -- Written to store in the parent directory\n                        output_dir = f\"{self.out_dir}/{hierarchy_info['name']}/{case_info['name']}/exp_set_{exp_set}/{refinement_level}/aoa_{aoa}\"\n                        aero_options['outputDirectory'] = output_dir\n\n                        # name of the simulation info file at the aoa level directory\n                        aoa_info_file = f\"{output_dir}/aoa_{aoa}.yaml\" \n\n\n                        aoa_level_dict = {} # Creating aoa level sim info dictionary for overall sim info file\n\n                        # Call 'run_as_subprocess' function if the user has requested\n                        if sim_info_copy['run_as_subprocess'] == 'yes':\n                            run_as_subprocess(sim_info_copy, hierarchy_info, case_info, exp_info, aoa, output_dir, sim_info_copy['nproc'], comm)\n\n                        ################################################################################\n                        # OpenMDAO setup\n                        ################################################################################\n\n                        os.environ[\"OPENMDAO_REPORTS\"]=\"0\" # Do this to disable report generation by OpenMDAO\n\n                        prob = om.Problem()\n                        prob.model = Top(case_info, exp_info, aero_options)\n\n                        # Checking for existing sucessful simualtion info, \n                        if os.path.exists(output_dir):\n                            try:\n                                with open(aoa_info_file, 'r') as aoa_file:\n                                    aoa_sim_info = yaml.safe_load(aoa_file)\n                                fail_flag = aoa_sim_info['fail_flag']\n                                if fail_flag == 0:\n                                    CLList.append(aoa_sim_info['cl'])\n                                    CDList.append(aoa_sim_info['cd'])\n                                    TList.append(float(aoa_sim_info['wall_time'].replace(\" sec\", \"\")))\n                                    FList.append(fail_flag)\n\n                                    # To Store in the overall simulation out file in case of skipping\n                                    aoa_level_dict = {\n                                        'cl': float(aoa_sim_info['cl']),\n                                        'cd': float(aoa_sim_info['cd']),\n                                        'wall_time': aoa_sim_info['wall_time'],\n                                        'fail_flag': int(fail_flag),\n                                        'out_dir': output_dir,\n                                    }\n                                    refinement_level_dict[f\"aoa_{aoa}\"] = aoa_level_dict\n\n                                    if comm.rank == 0:\n                                        print(f\"{'-'*50}\")\n                                        print(f\"{'NOTICE':^50}\")\n                                        print(f\"{'-'*50}\")\n                                        print(f\"Skipping Angle of Attack (AoA): {float(aoa):&lt;5} | Reason: Existing successful simulation found\")\n                                        print(f\"{'-'*50}\")\n                                    continue # Continue to next loop if there exists a successful simulation\n                            except:\n                                fail_flag = 1\n                        elif not os.path.exists(output_dir): # Create the directory if it doesn't exist\n                            if comm.rank == 0:\n                                os.makedirs(output_dir)\n\n\n                        if comm.rank == 0:\n                            print(f\"{'-'*50}\")\n                            print(f\"Starting Angle of Attack (AoA): {float(aoa):&lt;5}\")\n                            print(f\"{'-'*50}\")\n                        # Setup the problem\n                        prob.setup()\n\n                        # Set the angle\n                        prob[\"aoa\"] = float(aoa)\n\n                        om.n2(prob, show_browser=False, outfile=f\"{output_dir}/mphys_aero.html\")\n\n                        # Run the model\n                        aoa_start_time = time.time() # Stote the start time\n                        try:\n                            prob.run_model()\n                            fail_flag = 0\n                        except:\n                            fail_flag = 1\n\n                        aoa_end_time = time.time() # Store the end time\n                        aoa_run_time = aoa_end_time - aoa_start_time # Compute the run time\n\n                        prob.model.list_inputs(units=True)\n                        prob.model.list_outputs(units=True)\n\n                        # Store a Yaml file at this level\n                        aoa_out_dic = {\n                            'case': case_info['name'],\n                            'exp_info': exp_info,\n                            'mesh_file_used': f\"{case_info['meshes_folder_path']}/{mesh_file}\",\n                            'AOA': float(aoa),\n                            'cl': float(prob[\"cruise.aero_post.cl\"][0]),\n                            'cd': float(prob[\"cruise.aero_post.cd\"][0]),\n                            'refinement_level': refinement_level,\n                            'wall_time': f\"{aoa_run_time:.2f} sec\",\n                            'fail_flag': int(fail_flag),\n                            'out_dir': output_dir,\n                        }\n                        with open(aoa_info_file, 'w') as interim_out_yaml:\n                            yaml.dump(aoa_out_dic, interim_out_yaml, sort_keys=False)\n\n                        # To Store in the overall simulation out file\n                        aoa_level_dict = {\n                            'cl': float(prob[\"cruise.aero_post.cl\"][0]),\n                            'cd': float(prob[\"cruise.aero_post.cd\"][0]),\n                            'wall_time': f\"{aoa_run_time:.2f} sec\",\n                            'fail_flag': int(fail_flag),\n                            'out_dir': output_dir,\n                        }\n                        refinement_level_dict[f\"aoa_{aoa}\"] = aoa_level_dict\n\n                        # Adding cl, cd, wall time, Fail flags to their respective lists to create the csv file at refinement level\n                        CLList.append(float(prob[\"cruise.aero_post.cl\"][0]))\n                        CDList.append(float(prob[\"cruise.aero_post.cd\"][0]))\n                        TList.append(aoa_run_time)\n                        FList.append(fail_flag)\n\n\n                    # Write simulation results to a csv file\n                    refinement_level_data = {\n                        \"Alpha\": [f\"{alpha:6.2f}\" for alpha in aoa_list],\n                        \"CL\": [f\"{cl:8.4f}\" for cl in CLList],\n                        \"CD\": [f\"{cd:8.4f}\" for cd in CDList],\n                        \"FFlag\": [f\"{int(FF):12f}\" for FF in FList],\n                        \"WTime\": [f\"{wall_time:10.2f}\" for wall_time in TList]\n                    }\n\n                    # Define the output file path\n                    refinement_level_dir = os.path.dirname(output_dir)\n                    ADflow_out_file = f\"{refinement_level_dir}/ADflow_output.csv\"\n\n                    df = pd.DataFrame(refinement_level_data) # Create a panda DataFrame\n                    # Write the DataFrame to a CSV file\n                    df.to_csv(ADflow_out_file, index=False)\n\n                    # Add csv file location to the overall simulation out file\n                    refinement_level_dict['csv_file'] = ADflow_out_file\n                    refinement_level_dict['refinement_out_dir'] = refinement_level_dir\n\n                    # Add refinement level dict to exp level dict\n                    exp_sim_info[f\"{refinement_level}\"] = refinement_level_dict\n\n                # Add experimental level simulation to the overall simulation out file\n                exp_out_dir = os.path.dirname(refinement_level_dir)\n                exp_sim_info['exp_set_out_dir'] = exp_out_dir\n                sim_out_info['hierarchies'][hierarchy]['cases'][case]['exp_sets'][exp_set]['sim_info'] = exp_sim_info\n\n    end_time = time.time()\n    end_wall_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    net_run_time = end_time - start_time\n    sim_out_info['overall_sim_info'] = {\n        'start_time': start_wall_time,\n        'end_time': end_wall_time,\n        'total_wall_time': f\"{net_run_time:.2f} sec\"\n    }\n\n    # Store the final simulation out file.\n    if comm.rank == 0:\n        with open(self.final_out_file, 'w') as final_out_yaml_handle:\n            yaml.dump(sim_out_info, final_out_yaml_handle, sort_keys=False)\n    comm.Barrier()\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#utils.get_sim_data","title":"<code>get_sim_data(info_file, run_flag=RunFlag.skip)</code>","text":"<p>Generates a dictionary containing simulation data organized hierarchically.</p> <p>This function processes a YAML file with simulation information and creates a nested dictionary (<code>sim_data</code>) with details about simulation hierarchies, cases, experiment sets, refinement levels, and angles of attack. It also provides an option to run a simulation if the required data does not exist.</p>"},{"location":"reference/utils/#utils.get_sim_data--inputs","title":"Inputs","text":"<ul> <li>info_file : str     Path to the input YAML file containing simulation information or configuration.</li> <li>run_flag : RunFlag, optional     Enum to determine behavior if required simulation data is not found:<ul> <li><code>RunFlag.skip</code> (default): Exit without running the simulation.</li> <li><code>RunFlag.run</code>: Run the simulation and populate the data.</li> </ul> </li> </ul>"},{"location":"reference/utils/#utils.get_sim_data--outputs","title":"Outputs","text":"<p>sim_data: dict     A dictionary contating simulation data.</p> Source code in <code>simulateTestCases/utils.py</code> <pre><code>def get_sim_data(info_file, run_flag=RunFlag.skip):\n    \"\"\"\n    Generates a dictionary containing simulation data organized hierarchically.\n\n    This function processes a YAML file with simulation information and creates a\n    nested dictionary (`sim_data`) with details about simulation hierarchies, cases,\n    experiment sets, refinement levels, and angles of attack. It also provides an\n    option to run a simulation if the required data does not exist.\n\n    Inputs\n    ------\n    - **info_file** : str\n        Path to the input YAML file containing simulation information or configuration.\n    - **run_flag** : RunFlag, optional\n        Enum to determine behavior if required simulation data is not found:\n        - `RunFlag.skip` (default): Exit without running the simulation.\n        - `RunFlag.run`: Run the simulation and populate the data.\n\n    Outputs\n    -------\n    **sim_data**: dict\n        A dictionary contating simulation data.\n    \"\"\"\n    check_input_yaml(info_file)\n    if comm.rank == 0:\n        print(f\"{'-' * 50}\")\n        print(\"YAML file validation is successful\")\n        print(f\"{'-' * 50}\")\n    info = load_yaml_file(info_file, comm)\n    sim_data = {} # Initiating a dictionary to store simulation data\n\n    try:  # Check if the file is overall sim info file and stores the simulation info\n        overall_sim_info = info[\"overall_sim_info\"]\n        sim_info = copy.deepcopy(info)\n        print(f\"{'-' * 50}\")\n        print(f\"File provided is an ouput yaml file. Continuing to read data\")\n        print(f\"{'-' * 50}\")\n\n    except KeyError:  # if the file is input info file, loads the overall_sim_info.yaml if the simulation is run already\n        if comm.rank == 0:\n            print(f\"{'-' * 50}\")\n            print(f\"File provided is an input yaml file. Checking for existing simulation results in {info['out_dir']}\")\n            print(f\"{'-' * 50}\")\n        out_yaml_file_path = f\"{info['out_dir']}/overall_sim_info.yaml\"\n\n        if os.path.isfile(out_yaml_file_path):\n            sim_info = load_yaml_file(f\"{info['out_dir']}/overall_sim_info.yaml\", comm)\n        else:\n            if comm.rank == 0:\n                print(f\"{'-' * 50}\")\n                print(f\"No existing simulation found in {info['out_dir']}\")\n                print(f\"{'-' * 50}\")\n            if run_flag == RunFlag.run:\n                if comm.rank == 0:\n                    print(f\"{'-' * 50}\")\n                    print(\"Continuing to run simulation\")\n                    print(f\"{'-' * 50}\")\n                sim = run_sim(info_file)\n                sim.run()\n                sim_info = load_yaml_file(f\"{info['out_dir']}/overall_sim_info.yaml\", comm)\n            elif run_flag == RunFlag.skip:\n                if comm.rank == 0:\n                    print(f\"{'-' * 50}\")\n                    print(\"Exiting without running sumulations\")\n                    print(f\"{'-' * 50}\")\n                return sim_data\n\n\n    # Loop through hierarchy levels\n    for hierarchy_index, hierarchy_info in enumerate(sim_info['hierarchies']):\n        hierarchy_name = hierarchy_info['name']\n        if hierarchy_name not in sim_data:\n            sim_data[hierarchy_name] = {}\n\n        # Loop through cases in the hierarchy\n        for case_index, case_info in enumerate(hierarchy_info['cases']):\n            case_name = case_info['name']\n            if case_name not in sim_data[hierarchy_name]:\n                sim_data[hierarchy_name][case_name] = {}\n\n            # Loop through experiment sets in the case\n            for exp_index, exp_info in enumerate(case_info['exp_sets']):\n                exp_set_key = f\"exp_set_{exp_index}\"\n                if exp_set_key not in sim_data[hierarchy_name][case_name]:\n                    sim_data[hierarchy_name][case_name][exp_set_key] = {}\n\n                # Loop through mesh files\n                for ii, mesh_file in enumerate(case_info['mesh_files']):\n                    refinement_level = f\"L{ii}\"\n                    if refinement_level not in sim_data[hierarchy_name][case_name][exp_set_key]:\n                        sim_data[hierarchy_name][case_name][exp_set_key][refinement_level] = {}\n\n                    # Loop through angles of attack\n                    for aoa in exp_info['aoa_list']:\n                        aoa_key = f\"aoa_{aoa}\"\n                        cl = exp_info['sim_info'][refinement_level][aoa_key].get(\"cl\")\n                        cd = exp_info['sim_info'][refinement_level][aoa_key].get(\"cd\")\n\n                        # Populate the dictionary\n                        if aoa_key not in sim_data[hierarchy_name][case_name][exp_set_key][refinement_level]:\n                            sim_data[hierarchy_name][case_name][exp_set_key][refinement_level][aoa_key] = {}\n\n                        sim_data[hierarchy_name][case_name][exp_set_key][refinement_level][aoa_key]['cl'] = cl\n                        sim_data[hierarchy_name][case_name][exp_set_key][refinement_level][aoa_key]['cd'] = cd\n\n    return sim_data\n</code></pre>"},{"location":"reference/utils/#utils.run_30p30n","title":"<code>run_30p30n(case_info)</code>","text":"<p>Run the 30p30n simulation case.</p>"},{"location":"reference/utils/#utils.run_30p30n--inputs","title":"Inputs:","text":"<p>case_info : dict     A dictionary containing the case information.</p>"},{"location":"reference/utils/#utils.run_30p30n--outputs","title":"Outputs:","text":"<p>sim_data : dict     Simulation results and associated data for the 30p30n case.</p>"},{"location":"reference/utils/#utils.run_30p30n--notes","title":"Notes:","text":"<ul> <li>Uses the <code>run_case</code> function with '30p-30n' as the case name.</li> </ul> Source code in <code>simulateTestCases/utils.py</code> <pre><code>def run_30p30n(case_info):\n    \"\"\"\n    Run the 30p30n simulation case.\n\n    Inputs:\n    ----------\n    case_info : dict\n        A dictionary containing the case information.\n\n    Outputs:\n    -------\n    sim_data : dict\n        Simulation results and associated data for the 30p30n case.\n\n    Notes:\n    ------\n    - Uses the `run_case` function with '30p-30n' as the case name.\n    \"\"\"\n    sim_data = run_case('30p-30n', case_info)\n    case_data = sim_data['2d_high_lift']['30p-30n']['exp_set_0']\n\n    return case_data\n</code></pre>"},{"location":"reference/utils/#utils.run_case","title":"<code>run_case(case, case_info)</code>","text":"<p>Run a predefined case simulation.</p> <p>This function sets up and executes a simulation based on the provided case information. It validates the input, prepares a temporary directory for files, and cleans up after the run.</p>"},{"location":"reference/utils/#utils.run_case--inputs","title":"Inputs:","text":"<p>case : str     The name of the simulation case to run (e.g., 'naca0012', '30p-30n'). case_info : dict     A dictionary containing the case information. It should follow the structure defined by the <code>ref_case_info</code> class:     - <code>hpc</code> Optional(Literal['yes', 'no'])): Indicates whether to run on an HPC cluster ('yes') or locally ('no'). Defatlts to 'no'     - <code>hpc_info</code> (Optional[dict]): If <code>hpc</code> is 'yes', this should be a dictionary following the structure of <code>ref_hpc_info</code>:         - <code>job_name</code> (Optional[str]): Name of the job.         - <code>nodes</code> (Optional[str]): Number of nodes for the job.         - <code>nproc</code> (Optional[str]): Number of processors for the job.         - <code>account_name</code> (str): HPC account name.         - <code>email_id</code> (str): Email for job notifications.     - <code>meshes_folder_path</code> (str): Path to the directory containing mesh files.     - <code>mesh_files</code> (list[str]): List of mesh file names.     - <code>aoa_list</code> (list[float]): List of angles of attack for the simulation.     - <code>solver_parameters</code> (Optional[dict]): Dictionary of solver-specific parameters (optional).</p>"},{"location":"reference/utils/#utils.run_case--outputs","title":"Outputs:","text":"<p>sim_data : dict     Simulation results and associated data.</p>"},{"location":"reference/utils/#utils.run_case--notes","title":"Notes:","text":"<ul> <li>Creates a temporary directory for the simulation input and output files.</li> <li>Deletes the temporary directory after the simulation run.</li> </ul> Source code in <code>simulateTestCases/utils.py</code> <pre><code>def run_case(case, case_info):\n    \"\"\"\n    Run a predefined case simulation.\n\n    This function sets up and executes a simulation based on the provided case information.\n    It validates the input, prepares a temporary directory for files, and cleans up after the run.\n\n    Inputs:\n    ----------\n    case : str\n        The name of the simulation case to run (e.g., 'naca0012', '30p-30n').\n    case_info : dict\n        A dictionary containing the case information. It should follow the structure defined by the `ref_case_info` class:\n        - `hpc` Optional(Literal['yes', 'no'])): Indicates whether to run on an HPC cluster ('yes') or locally ('no'). Defatlts to 'no'\n        - `hpc_info` (Optional[dict]): If `hpc` is 'yes', this should be a dictionary following the structure of `ref_hpc_info`:\n            - `job_name` (Optional[str]): Name of the job.\n            - `nodes` (Optional[str]): Number of nodes for the job.\n            - `nproc` (Optional[str]): Number of processors for the job.\n            - `account_name` (str): HPC account name.\n            - `email_id` (str): Email for job notifications.\n        - `meshes_folder_path` (str): Path to the directory containing mesh files.\n        - `mesh_files` (list[str]): List of mesh file names.\n        - `aoa_list` (list[float]): List of angles of attack for the simulation.\n        - `solver_parameters` (Optional[dict]): Dictionary of solver-specific parameters (optional).\n\n    Outputs:\n    -------\n    sim_data : dict\n        Simulation results and associated data.\n\n    Notes:\n    ------\n    - Creates a temporary directory for the simulation input and output files.\n    - Deletes the temporary directory after the simulation run.\n    \"\"\"\n    ref_case_info.model_validate(case_info)\n    # Validate or set default for 'hpc'\n    if 'hpc' not in case_info:\n        case_info['hpc'] = 'no'\n\n    if case_info['hpc'] == 'yes':\n        ref_hpc_info.model_validate(case_info['hpc_info'])\n\n    if comm.rank == 0:\n        randn = random.randint(1000, 9999)\n    else:\n        # Other processes initialize the variable\n        randn = None\n\n    # Broadcast the random number to all processes\n    randn = comm.bcast(randn, root=0)\n\n    cwd = os.getcwd()\n    temp_dir = f\"{cwd}/temp_{randn}\"\n    if comm.rank == 0:\n        print(f\"{'-' * 50}\")\n        print(\"Creating a the temporary folder to run simulations\")\n        print(f\"{'-' * 50}\")\n        os.mkdir(temp_dir)\n\n\n    input_file  = f\"{case}_simInfo.yaml\"\n    with pkg_resources.open_text('simulateTestCases.resources', input_file) as f:\n        sim_info = yaml.safe_load(f)\n    try:\n        sim_info['hpc'] = case_info['hpc']\n    except:\n        if comm.rank == 0 and case_info['hpc'] == 'yes':\n            print(f\"{'-' * 50}\")\n            print(\"HPC options are not being updated. Which may cause errors in submission of jobs\")\n            print(f\"{'-' * 50}\")\n\n    sim_info['hierarchies'][0]['cases'][0]['meshes_folder_path'] = case_info['meshes_folder_path']\n    sim_info['hierarchies'][0]['cases'][0]['mesh_files'] = case_info['mesh_files']\n    sim_info['hierarchies'][0]['cases'][0]['exp_sets'][0]['aoa_list'] = case_info['aoa_list']\n    try: # As solver parameters are optional.\n        sim_info['hierarchies'][0]['cases'][0]['meshes_folder_path'].update(case_info['solver_parameters'])\n    except:\n        if comm.rank == 0:\n            print(f\"{'-' * 50}\")\n            print(\"Solver parameters are not being updated\")\n            print(f\"{'-' * 50}\")\n\n\n\n    comm.Barrier()\n\n    if 'out_dir' in case_info:\n        sim_info['out_dir'] = case_info['out_dir']\n    else:\n        sim_info['out_dir'] = f\"{cwd}/{temp_dir}/output\"\n\n    new_input_file = f\"{temp_dir}/input.yaml\"\n    with open(new_input_file, 'w') as f:\n        yaml.safe_dump(sim_info, f)\n\n    comm.Barrier()\n\n    # Execute simulation\n    sim = run_sim(new_input_file)\n    sim.run()\n    sim_data = get_sim_data(new_input_file, run_flag=RunFlag.skip)\n\n    comm.Barrier()\n    if comm.rank == 0:\n        print(f\"{'-' * 50}\")\n        print(\"Deleting the temporary folder\")\n        print(f\"{'-' * 50}\")\n        shutil.rmtree(temp_dir)\n\n    return sim_data\n</code></pre>"},{"location":"reference/utils/#utils.run_naca0012","title":"<code>run_naca0012(case_info)</code>","text":"<p>Run the NACA 0012 simulation case.</p>"},{"location":"reference/utils/#utils.run_naca0012--inputs","title":"Inputs:","text":"<p>case_info : dict     A dictionary containing the case information. </p>"},{"location":"reference/utils/#utils.run_naca0012--outputs","title":"Outputs:","text":"<p>sim_data : dict     Simulation results and associated data for the NACA 0012 case.</p>"},{"location":"reference/utils/#utils.run_naca0012--notes","title":"Notes:","text":"<ul> <li>Uses the <code>run_case</code> function with 'naca0012' as the case name.</li> </ul> Source code in <code>simulateTestCases/utils.py</code> <pre><code>def run_naca0012(case_info):\n    \"\"\"\n    Run the NACA 0012 simulation case.\n\n    Inputs:\n    ----------\n    case_info : dict\n        A dictionary containing the case information. \n\n    Outputs:\n    -------\n    sim_data : dict\n        Simulation results and associated data for the NACA 0012 case.\n\n    Notes:\n    ------\n    - Uses the `run_case` function with 'naca0012' as the case name.\n    \"\"\"\n    sim_data = run_case('naca0012', case_info)\n    case_data = sim_data['2d_clean']['NACA0012']['exp_set_0']\n    return case_data\n</code></pre>"},{"location":"reference/resources/","title":"resources","text":""},{"location":"tutorials/inputs/","title":"Inputs","text":"<p>The <code>simulateTestCases</code> package requires the following inputs to configure and execute simulations:</p>"},{"location":"tutorials/inputs/#yaml-configuration-file","title":"YAML Configuration File","text":"<p>A YAML file is required to define the simulation parameters and organize test cases. The YAML file structure and respective descriptions are given below.</p>"},{"location":"tutorials/inputs/#input-yaml-file-structure","title":"Input YAML file Structure","text":"<p>The YAML file organizes simulation data into a structured hierarchy, enabling clear configuration of cases and experimental conditions. Below is the structure used in the YAML file:</p> <pre><code>out_dir: # str, path to the output directory\nrun_as_subprocess: # str, 'yes' or 'no'\nnproc: # int, number of processors, required only if run_as_subprocess is yes\nhpc: # str, 'yes' or 'no'\nhpc_info: # dict, required only if hpc is yes\n  cluster: # str, name of the cluster. GL for Great Lakes\n  job_name: # str, name of the job\n  nodes: # int, number of nodes\n  nproc: # int, total number of processors\n  time: #str, time in D-H:M:S format\n  account_name: # str, account name\n  email_id: # str\nhierarchies: # list, List of hierarchies\n# First hierarchy\n- name: # str, name of the hierarchy\n  cases: # list, list of cases in this hierarchy\n  # First case in the hierarchy\n  - name: # str, name of the case\n    meshes_folder_path: # str, path to the floder containing the mesh files for this case\n    mesh_files: # list, list of mesh file names\n    - # str, name of the finest mesh\n    - # str, .\n    - # str, .\n    - # str, name of the corasest mesh\n    geometry_info: # dict, dictionary of geometry info\n      chordRef: # float, reference chord length\n      areaRef: # flaot, reference area\n    solver_parameters: # dict, dictionary of solver parameters. For more information see solver parameters section\n      # ......\n    exp_sets: # list, list of dictionaries contating experimental info\n    # First experimental set in current case\n    - aoa_list: # list, list of angle of attacks(AoA) to run in with the experimental info\n      Re: # float, Reynold's number \n      mach: # float, Mach number\n      Temp: # float, Temperature in Kelvin scale\n      exp_data: # str, path to experimental data\n\n    # Second experimental set in current case\n\n  # Second case in current hierachy\n\n# Second hierarchy\n</code></pre> <p>Please note that adherence to this structure is essential; any deviation may lead to errors when running simulations. Examples of correctly formatted YAML files are provided in the <code>examples/inputs</code> folder. The file <code>naca0012_simInfo.yaml</code> is an example file to run NACA0012 airfoil without the <code>run_as_subprocess</code> option, and <code>30p-30n_simInfo.yaml</code> is with <code>run_as_subprocess</code> option.</p> <p>The yaml script can also be used as a starting point for generating custom YAML files.</p>"},{"location":"tutorials/inputs/#solver-parameters","title":"Solver Parameters","text":"<p>The Solver parameters is a dictionary containing options specific to the ADflow CFD solver, allowing users to customize the solver's behavior to suit their simulation needs. Detailed descriptions of these parameters and their usage can be found in the ADflow Documentation. </p> <p>If the dictionary is empty or if the default parameters are not modified, the code will use a predefined set of default solver options. These defaults are designed to provide a reliable baseline configuration for running simulations effectively without requiring manual adjustments.</p>"},{"location":"tutorials/inputs/#default-solver-parameters","title":"Default Solver Parameters:","text":"<pre><code># Print Options\n\"printIterations\": False,\n\"printAllOptions\": False,\n\"printIntro\": False,\n\"printTiming\": False,\n# I/O Parameters\n\"gridFile\": f\"grids/naca0012_L1.cgns\", # Default grid file\n\"outputDirectory\": \".\",\n\"monitorvariables\": [\"resrho\", \"resturb\", \"cl\", \"cd\", \"yplus\"],\n\"writeTecplotSurfaceSolution\": True,\n# Physics Parameters\n\"equationType\": \"RANS\",\n\"liftindex\": 3,  # z is the lift direction\n# Solver Parameters\n\"smoother\": \"DADI\",\n\"CFL\": 0.5,\n\"CFLCoarse\": 0.25,\n\"MGCycle\": \"sg\",\n\"MGStartLevel\": -1,\n\"nCyclesCoarse\": 250,\n# ANK Solver Parameters\n\"useANKSolver\": True,\n\"nsubiterturb\": 5,\n\"anksecondordswitchtol\": 1e-4,\n\"ankcoupledswitchtol\": 1e-6,\n\"ankinnerpreconits\": 2,\n\"ankouterpreconits\": 2,\n\"anklinresmax\": 0.1,\n# Termination Criteria\n\"L2Convergence\": 1e-12,\n\"L2ConvergenceCoarse\": 1e-2,\n\"nCycles\": 75000,\n</code></pre>"},{"location":"tutorials/inputs/#experimental-conditions","title":"Experimental Conditions","text":"<p>To define the problem, referred to as the AeroProblem (focused on aerodynamics), the following conditions along with the Angle of Attack(AoA) and path to the experimental data:</p> <ul> <li>Reynolds number</li> <li>Mach number</li> <li>Temperature</li> <li>Reynolds length (Computed from geometrical data)</li> </ul> <p>Other properties, such as pressure or density, will be calculated automatically based on the specified values and the governing gas laws.</p> <p>The <code>Angle of Attack (AoA)</code> is required to define the aerodynamic orientation of the flow. The <code>path to experimental data</code> can be left blank, as it will not affect the simulation. However, leaving it blank will generate a warning during the post-processing stage.</p>"},{"location":"tutorials/inputs/#location-of-mesh-files","title":"Location of Mesh Files","text":"<p>Specifying the location of the mesh files requires two inputs in every case: </p> <ul> <li><code>meshes_folder_path</code> gets the path to the folder that contains the mesh files</li> <li><code>mesh_files</code> gets the list of file names, that to be run, in the folder specified above.</li> </ul>"},{"location":"tutorials/introduction/","title":"Introduction","text":"<p>The <code>simulateTestCases</code> package is a Python-based tool designed to streamline the execution and data management of ADflow simulations. It integrates with MPhys to provide a structured framework for running aerodynamic flow simulations and organizing the resulting data in a hierarchical manner.</p> <p>This package is particularly suited for projects involving multiple configurations or test cases, ensuring that simulation results are stored and categorized systematically.</p>"},{"location":"tutorials/introduction/#key-features","title":"Key Features","text":"<ul> <li>Automates the execution of multiple ADflow simulation cases.</li> <li>Allows the user to choose to run the simulations as subprocesses.</li> <li>Utilizes YAML configuration files for defining simulation parameters and organizing cases.</li> <li>Stores simulation data in a structured directory hierarchy for ease of access and analysis.</li> <li>Supports post-processing with methods for comparing results to experimental data and generating plots.</li> </ul>"},{"location":"tutorials/introduction/#inputs","title":"Inputs","text":"<p>The <code>simulateTestCases</code> package requires the following inputs:</p> <ol> <li> <p>YAML Configuration File:</p> <p>A YAML file specifying:</p> <ul> <li>Simulation hierarchy.</li> <li>Mesh files and solver parameters.</li> <li>Experimental conditions (e.g., Reynolds number, Mach number, and angle of attack).</li> </ul> </li> <li> <p>Output Directory:</p> <p>A directory path where the simulation results will be saved. The structure of this directory mirrors the hierarchy defined in the YAML file.</p> </li> </ol>"},{"location":"tutorials/introduction/#outputs","title":"Outputs","text":"<p>The outputs of <code>simulateTestCases</code> are stored in directories organized according to the simulation hierarchy. These include:</p> <ol> <li> <p>Simulation Data:</p> <p>Results such as C_L, C_D, and Wall Time are saved in CSV and YAML formats.</p> </li> <li> <p>Hierarchical Directory Structure:</p> <p>Output directories follow the YAML-defined hierarchy, allowing for easy navigation of results.</p> </li> <li> <p>Visualization:</p> <p>Comparison plots (e.g., experimental vs. simulated data) are generated in PNG format.</p> </li> </ol>"},{"location":"tutorials/introduction/#example-hierarchy","title":"Example Hierarchy","text":"<p>The package organizes simulation data into a clear and logical hierarchy. An example of this structure, that has been used in the tutorials is shown below:</p> <p><pre><code>Aero Problem\n    |\n    |---- 2D Clean\n    |       |\n    |       |---- NACA 0012\n    |\n    |---- 2D High-Lift\n    |       |\n    |       |---- Mc Donnell Dolugas 30P-30N\n    |\n    |---- 3D Clean\n    |       |\n    |       |---- NASA CRM clean Configuration\n    |\n    |---- 3D High-Lift\n            |\n            |---- DLR High-Lift Configuration\n</code></pre> Explanation of the Hierarchy:</p> <ol> <li> <p>Aero Problem: Categorizes the type of aerodynamic analysis, such as clean flow or high-lift studies, in 2D or 3D configurations.</p> </li> <li> <p>2D Clean: Simulations for 2D configurations without high-lift devices (e.g., NACA 0012 airfoil).</p> </li> <li> <p>2D High-Lift: Simulations for 2D configurations with high-lift devices (e.g., McDonnell Douglas 30P-30N airfoil).</p> </li> <li> <p>3D Clean: Simulations for 3D configurations without high-lift devices (e.g., NASA Common Research Model Clean Configuration).</p> </li> <li> <p>3D High-Lift: Simulations for 3D configurations with high-lift devices (e.g., DLR High-Lift Configuration).</p> </li> </ol>"},{"location":"tutorials/outputs/","title":"Outputs","text":"<p>The <code>simulateTestCases</code> package organizes simulation results into a structured directory hierarchy. This hierarchy mirrors the simulation setup defined in the YAML file.</p>"},{"location":"tutorials/outputs/#structure-of-the-output-directory","title":"Structure of the Output Directory","text":""},{"location":"tutorials/outputs/#file-types","title":"File Types","text":"<ol> <li> <p>CSV Files:</p> <ul> <li>Stored in Refinement Level directory </li> <li>Contain simulation data, including:<ul> <li>Coefficient of Lift (C<sub>L</sub>)</li> <li>Coefficient of Drag (C<sub>D</sub>)</li> <li>Wall Time</li> </ul> </li> </ul> </li> <li> <p>YAML Files:</p> <ul> <li>Two types:<ul> <li>Per-case YAML files (<code>out.yaml</code>) stored in each AoA directory.</li> <li>A summary YAML file for the entire simulation.</li> </ul> </li> </ul> </li> <li> <p>PNG Files:</p> <ul> <li>Comparison plots of experimental vs. simulated data, stored in the corresponding experimental level level directory.</li> </ul> </li> </ol> <p>This structure ensures that simulation results are easy to navigate and analyze.</p>"},{"location":"tutorials/test_cases/","title":"Test Cases and Expected Results","text":"<p>An example hierarchy is provided in the Introduction. This hierarchy serves as a reference for understanding the structure and workflow.</p> <p>When the supplied grid files and experimental data are used, the expected results for this hierarchy are outlined on this page.</p>"},{"location":"tutorials/test_cases/#hierarchy-2d-clean","title":"Hierarchy: 2D Clean","text":""},{"location":"tutorials/test_cases/#case-naca-0012","title":"Case: NACA 0012","text":"<p>Geomerty Info: <pre><code>areaRef: 1.0\nchordRef: 1.0\n</code></pre> Solver Parameters Used: <pre><code>useANKSolver: true\nnSubiterTurb: 20\nuseNKSolver: false\nNKSwitchTol: 1.0e-06\nANKCoupledSwitchTol: 0.001\nANKSecondOrdSwitchTol: 1.0e-12\nL2Convergence: 1.0e-08\nnCycles: 150000\nliftIndex: 2\n</code></pre></p>"},{"location":"tutorials/test_cases/#experimental-set-1","title":"Experimental Set: 1","text":"<p>Experimental Conditions: <pre><code>Re: 3900000.0\nmach: 0.3\nTemp: 298.0\n</code></pre></p> <p>      NACA 0012 (Exp Set: 1) Results      </p>"},{"location":"tutorials/test_cases/#hierarchy-2d-high-lift","title":"Hierarchy: 2D High-Lift","text":""},{"location":"tutorials/test_cases/#case-mc-donnell-dolugas-30p-30n","title":"Case: Mc Donnell Dolugas 30P-30N","text":"<p>Geomerty Info: <pre><code>areaRef: 1.0\nchordRef: 1.0\n</code></pre> Solver Parameters Used: <pre><code>useANKSolver: true\nnSubiterTurb: 20\nuseNKSolver: false\nNKSwitchTol: 0.0001\nANKCoupledSwitchTol: 1.0e-07\nANKSecondOrdSwitchTol: 1.0e-05\nL2Convergence: 1.0e-10\nnCycles: 150000\nliftIndex: 2\nnearWallDist: 0.01\n</code></pre></p>"},{"location":"tutorials/test_cases/#experimental-set-1_1","title":"Experimental Set: 1","text":"<p>Experimental Conditions: <pre><code>Re: 9000000.0\nmach: 0.2\nTemp: 298.0\n</code></pre></p> <p>      30P-30N (Exp Set: 1) Results      </p>"},{"location":"tutorials/test_cases/#hierarchy-3d-clean","title":"Hierarchy: 3D Clean","text":""},{"location":"tutorials/test_cases/#case-nasa-common-research-model-clean-configuration","title":"Case: NASA Common Research Model, Clean Configuration","text":"<p>Geomerty Info: <pre><code>areaRef: 191.845\nchordRef: 7.00532\n</code></pre></p> <p>Solver Parameters Used: <pre><code>useZipperMesh: True\nuseANKSolver: True\nnSubiterTurb: 5\nuseNKSolver: False\nANKCoupledSwitchTol: 1e-7\nANKSecondOrdSwitchTol: 1e-6\nL2Convergence: 1e-10\nnCycles: 150000\nliftIndex: 3\n</code></pre></p>"},{"location":"tutorials/test_cases/#experimental-set-1_2","title":"Experimental Set: 1","text":"<p>Experimental Conditions: <pre><code>Re: 5000000.0\nmach: 0.85\nTemp: 322.039\n</code></pre></p> <p>      CRM Clean (Exp Set: 1) Results      </p>"},{"location":"tutorials/test_cases/#experimental-set-2","title":"Experimental Set: 2","text":"<p>Experimental Conditions: <pre><code>Re: 5000000.0\nmach: 0.70\nTemp: 299.817\n</code></pre></p> <p>      CRM Clean (Exp Set: 2) Results      </p>"},{"location":"tutorials/test_cases/#hierarchy-3d-high-lift","title":"Hierarchy: 3D High-Lift","text":""},{"location":"tutorials/test_cases/#case-dlr-f11-high-lift-configuration","title":"Case: DLR F11, High-Lift Configuration","text":"<p>Geomerty Info: <pre><code>areaRef: 0.41913\nchordRef: 0.34709\n</code></pre> Solver Parameters Used: <pre><code>useZipperMesh: True\nuseANKSolver: True\nnSubiterTurb: 7\nuseNKSolver: False\nANKCoupledSwitchTol: 1e-7\nANKSecondOrdSwitchTol: 1e-6\nL2Convergence: 1e-10\nnCycles: 150000\nliftIndex: 3\n</code></pre></p>"},{"location":"tutorials/test_cases/#experimental-set-1_3","title":"Experimental Set: 1","text":"<p>Experimental Conditions: <pre><code>Re: 1350000.0\nmach: 0.175\nTemp: 298.15\n</code></pre> TBD</p>"},{"location":"tutorials/usage/","title":"Usage","text":""},{"location":"tutorials/usage/#run-a-script-from-examples","title":"Run a script from examples","text":"<p>The script below runs a simulation of the NACA 0012 Airfoil, and is included in the <code>examples</code> folder. </p> <p>To run the above python script:</p> <ul> <li>Copy the examples directory to a different location:</li> </ul> <pre><code>$ cp -r &lt;path-to-repository&gt;/examples &lt;path-to-examples-directory&gt; \n</code></pre> <ul> <li>Navigate into the directory:</li> </ul> <pre><code>$ cd &lt;path-to-examples-directory&gt; \n</code></pre> <ul> <li>Run the python script with a single processor or when using <code>run_as_subprocess</code> option:</li> </ul> <pre><code>$ python run_example.py --inputFile &lt;path-to-input-yaml-file&gt;\n</code></pre> <p>or run with multiple processors</p> <pre><code>$ mpirun -np &lt;number of processors&gt; python run_example.py --inputFile &lt;path-to-input-yaml-file&gt;\n</code></pre> <p>Note:</p> <ul> <li>Do not use <code>mpirun</code> when using <code>run_as_subprocess</code> as it will result in an error</li> <li>Example input yaml files to run on personal computers are stored in <code>examples/inputs</code> directory, and for Great Lakes HPC cluster, an example file is stored in <code>examples/inputs/GL</code></li> <li>Make sure to modify the file and file paths ti absolute paths in the yaml file when running in a docker container.</li> </ul> <p>Use <code>examples/inputs/naca0012_sinInfo.yaml</code> or <code>examples/inputs/GL/naca0012_sinInfo.yaml</code>(for Great Lakes) to test the package with NACA0012 airfoil.</p> <p>After execution, the following results are expected which are saved in the specified output directory.</p> <ul> <li>A copy of the input yaml file in the output directory.</li> <li><code>overall_sim_info.yaml</code> in the output directory.</li> <li><code>ADflow_Results.png</code> in each experimental level directory, that is a plot comparing C<sub>L</sub>, and C<sub>D</sub> values at all refinement levels to the expeimental data(if provided).</li> </ul> <p> </p> <ul> <li><code>ADflow_output.csv</code> in each refinement level directory, that is a file containg Angle of Attack(AoA), C<sub>L</sub>, and C<sub>D</sub> data.</li> <li><code>aoa_&lt;aoa&gt;.yaml</code> in aoa level directory, that contains the simulation information particular to that angle of attack.</li> <li>Default ADflow outputs: A tecplot file, a CGNS surface file, and a CGNS volume file.</li> </ul>"},{"location":"tutorials/usage/#example-usage","title":"Example usage","text":"<p>Here are quick examples of how to different classes and functions in <code>simulateTestCases</code>:</p>"},{"location":"tutorials/usage/#running-simulations","title":"Running Simulations","text":"<pre><code>from simulateTestCases.run_sim import run_sim\n\n# Initialize the runner with configuration file\nsim = run_sim('/path/to/input-yaml-file')\n\n# Run the simulation series\nsim.run()\n\n# Analyze results\nsim.post_process()\n</code></pre>"},{"location":"tutorials/usage/#read-existing-simualtion-data-or-generate-data","title":"Read existing simualtion data or generate data","text":"<p>The function <code>get_sim_data</code> can be used to get existing simulation data that was generated after a simulation, or to generate new simulation data by passing a <code>run_flag</code>. If <code>run_flag</code> is <code>1</code>, then the function runs the simulation and outputs the data as a dictionary.</p> <p>The function provides the flexibility of using the input YAML file or  the <code>overall_sim_info.yaml</code> file that is generated and stored in the outptut directory after the completion of simulations, as inputs.</p> <pre><code>from simulateTestCases.utils import get_sim_data, RunFlag\n\n# Specify the path to the input file.\ninfo_file = '/path/to/input-yaml-file'\n\n# Call the function to get simulation data as a dictionary\nsim_data = get_sim_data(info_file, RunFlag.skip)\n\n# Print the dictionary\nprint(sim_data)\n</code></pre>"},{"location":"tutorials/usage/#custom-simulations","title":"Custom Simulations","text":"<p>The <code>run_naca0012</code> and <code>run_30p30n</code> functions allow users to run simulations without the need to generate an input YAML file. Instead, users can supply a dictionary of basic parameters. These functions load the respective YAML files and update it with the information provided by the user. </p> <p>Users can specify an output directory to save the simulation data; otherwise, the data will be stored in a temporary file and deleted after the simulation completes.</p> <p>Note: These functions are intended to use in a python script. If you want to run on a HPC, create a job script and submit it manually.</p>"},{"location":"tutorials/usage/#template-for-input-dictionary","title":"Template for Input Dictionary","text":"<pre><code>case_info = {\n    'out_dir': '',  # (Optional) str, path to output directory\n    'meshes_folder_path': '', # str, path to the folder containing mesh files.\n    'mesh_files': [],         # list[str], list of mesh file names.\n    'aoa_list': [],           # list[float], list of angles of attack to simulate.\n    'solver_parameters': {},  # (Optional) dict, dictionary of solver-specific parameters to update.\n}\n</code></pre>"},{"location":"tutorials/usage/#example-usage_1","title":"Example Usage","text":"<pre><code>from simulateTestCases.utils import run_naca0012\n\ncase_info = {\n    'meshes_folder_path': '/path/to/meshes',\n    'mesh_files': ['naca0012_L0.cgns'],\n    'aoa_list': [0],\n}\n\nsim_data = run_naca0012(case_info)\n\nprint(sim_data)\n</code></pre>"},{"location":"tutorials/usage/#additional-information","title":"Additional Information","text":""},{"location":"tutorials/usage/#grid-files","title":"Grid Files","text":"<p>Grids for NACA 0012 and Mc Donnell Dolugas 30P-30N are provided under <code>examples/grids</code> in the examples directory. The other grids (CRM clean, and DLR High-Lift) including Naca 0012 and 30P-30N can be found at Dropbox folder.</p>"},{"location":"tutorials/usage/#experimental-data","title":"Experimental data","text":"<p>Experimental data for NACA 0012 and Mc Donnell Dolugas 30P-30N are provided under <code>examples/exp_data</code> in the examples directory. The other dat (CRM clean, and DLR High-Lift) including Naca 0012 and 30P-30N, and their references can be found at Dropbox folder.</p>"}]}