{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"simulateTestCases","text":"<p><code>simulateTestCases</code> is a Python package designed for running a series of ADflow simulations using Mphys and OpenMDAO. This package provides streamlined functions to automate simulation test cases.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Simplifies running multiple simulation cases with ADflow.</li> <li>Integrates with Mphys and OpenMDAO for streamlined data management.</li> <li>Generates comparison plots for experimental conditions in each case.</li> </ul>"},{"location":"additionalInfo/","title":"Additional Information","text":"<ul> <li>For more information on ADflow code vist ADflow Documentation</li> <li>Documentation for MPhys, and the available scenarios can be found at MPhys Documentation</li> <li>Instructions for insalling dependencies can be found at MACH Aero Documentation</li> </ul>"},{"location":"installation/","title":"Installation and Dependencies","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":""},{"location":"installation/#core-framework-dependencies","title":"Core Framework Dependencies","text":"<p>The framework requires tools developed by NASA (OpenMDAO and MPhys) and the MDO Lab (MACH-Aero framework). The MACH-Aero framework houses all the core packages needed to run CFD simulations. Below is the list of software required:</p> <ul> <li><code>OpenMDAO</code></li> <li><code>MPhys</code></li> <li><code>baseClasses</code></li> <li><code>pySpline</code></li> <li><code>pyGeo</code></li> <li><code>IDWarp</code></li> <li><code>ADflow</code></li> <li><code>pyOptSparse</code></li> <li><code>TACS</code> (optional)</li> </ul> <p>These software packages may have additional third-party dependencies like PETSc and OpenMPI. A detailed guide for installing them from scratch is available here.</p>"},{"location":"installation/#python-libraries","title":"Python Libraries","text":"<p>The following Python libraries are required and can be installed via <code>pip</code>:</p> <ul> <li><code>numpy&gt;=1.21</code></li> <li><code>scipy&gt;=1.7</code></li> <li><code>mpi4py&gt;=3.1.4</code></li> <li><code>petsc4py</code></li> <li><code>pyyaml</code></li> <li><code>matplotlib</code></li> <li><code>pandas</code></li> <li><code>pydantic</code></li> </ul>"},{"location":"installation/#getting-started","title":"Getting Started","text":"<p>To get started, install the required dependencies first. Follow the detailed steps provided in the sections below.</p>"},{"location":"installation/#installation-of-dependencies","title":"Installation of Dependencies","text":""},{"location":"installation/#from-scratch","title":"From Scratch","text":"<p>To manually install all dependencies:</p> <ol> <li>Refer to the Scratch Installation Guide.</li> <li>A custom bash script <code>install_packages.sh</code> is available in this repository to automate the process. Follow <code>STEP 2</code> in the Scratch Installation section.</li> </ol> <p>Note: When installing dependencies from scratch, ensure that the <code>petsc4py</code> version matches the <code>petsc</code> version being installed. This library must be installed separately, as it cannot be bundled with the package.</p>"},{"location":"installation/#using-docker-recommended","title":"Using Docker (Recommended)","text":"<p>Docker is highly recommended for ease of installation:</p> <ol> <li>Pull a Docker image compatible with your machine's architecture. Official images for GCC and INTEL compilers are available here.</li> <li>Follow the Docker Guide to set up Docker.</li> <li>Initialize and start a container, mount the directory, and install this package. Follow the instructions mentioned here to initialize and start a container.</li> <li>Once in the container, follow the instructions in the Package Installation section to clone this repository in the mount directory and install it.</li> </ol> <p>Note: If you are referencing any paths inside the container, they must be with respect to the container's folder architecture, not your host machine.</p>"},{"location":"installation/#hpc-systems","title":"HPC Systems","text":"<p>For installation on HPC clusters like Great Lakes or NASA HECC:</p> <ol> <li>Install dependencies as modules or compile them manually. Most packages are available in HPC environments as modules.</li> <li>Follow the Scratch Installation instructions.</li> </ol>"},{"location":"installation/#package-installation","title":"Package Installation","text":"<p>The following steps are common for personal computers and HPC systems:</p> <ol> <li>Clone the repository:     <pre><code>git clone https://github.com/gorodetsky-umich/simulateTestCases.git\n</code></pre></li> <li>Navigate into the directory:     <pre><code>cd simulateTestCases\n</code></pre></li> <li>Install the package:<ul> <li>Without dependencies:     <pre><code>pip install .\n</code></pre></li> <li>With dependencies:     <pre><code>pip install . -r requirements.txt\n</code></pre></li> <li>Editable installation:     <pre><code>pip install -e .\n</code></pre></li> </ul> </li> </ol>"},{"location":"installation/#scratch-installation","title":"Scratch Installation","text":""},{"location":"installation/#hpc-cluster-setup-eg-great-lakes","title":"HPC Cluster Setup (e.g., Great Lakes)","text":"<ol> <li> <p>Add the following lines to your <code>~/.bashrc</code> file:     <pre><code># Load required modules\nmodule load gcc              # GNU Compiler\nmodule load openmpi          # MPI Libraries\nmodule load python/3.9.12    # Python 3.9.12\nmodule load cmake            # CMake for build systems\n\n# PETSc Installation\nexport PETSC_ARCH=real-opt\nexport PETSC_DIR=&lt;directory-path&gt;/packages/petsc-3.15.3\n\n# CGNS Installation\nexport CGNS_HOME=&lt;directory-path&gt;/packages/CGNS-4.4.0/opt-gfortran\nexport PATH=$PATH:$CGNS_HOME/bin\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CGNS_HOME/lib\n</code></pre>     Replace <code>&lt;directory-path&gt;</code> with your installation directory path. Do not forget to <code>source ~/.bashrc</code> after editing.</p> </li> <li> <p>Clone the repository:     <pre><code>git clone https://github.com/gorodetsky-umich/simulateTestCases.git\n</code></pre></p> <p>Copy and execute the installation script: <pre><code>$ cd simulateTestCases\n\n$ cp simulateTestCases/install_packages_gl.sh &lt;directory-path&gt;/\n\n$ chmod +x install_packages_gl.sh\n\n$ ./install_packages_gl.sh\n</code></pre></p> </li> </ol>"},{"location":"installation/#singularity","title":"Singularity","text":"<p>(To Be Documented)</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>helpers</li> <li>run_sim</li> <li>utils</li> </ul>"},{"location":"reference/helpers/","title":"helpers","text":""},{"location":"reference/helpers/#helpers.check_input_yaml","title":"<code>check_input_yaml(yaml_file)</code>","text":"<p>Validates the structure of the input YAML file against predefined templates.</p> <p>This function checks whether the input YAML file conforms to the expected template structure. It validates each section, including simulation, HPC, hierarchies, cases, and experimental sets.</p>"},{"location":"reference/helpers/#helpers.check_input_yaml--inputs","title":"Inputs","text":"<ul> <li>yaml_file : str     Path to the YAML file to be validated.</li> </ul>"},{"location":"reference/helpers/#helpers.check_input_yaml--outputs","title":"Outputs","text":"<p>ValidationError     If the YAML file does not conform to the expected structure.</p>"},{"location":"reference/helpers/#helpers.check_input_yaml--notes","title":"Notes","text":"<ul> <li>Uses <code>ref_sim_info</code>, <code>ref_hpc_info</code>, and other reference pydantic models listed in <code>yaml_config.py</code> for validation.</li> <li>Ensures hierarchical consistency by iterating through all levels of the YAML structure.</li> </ul> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def check_input_yaml(yaml_file):\n    \"\"\"\n    Validates the structure of the input YAML file against predefined templates.\n\n    This function checks whether the input YAML file conforms to the expected template structure. It validates each section, including simulation, HPC, hierarchies, cases, and experimental sets.\n\n    Inputs\n    ----------\n    - **yaml_file** : str\n        Path to the YAML file to be validated.\n\n    Outputs\n    ------\n    **ValidationError**\n        If the YAML file does not conform to the expected structure.\n\n    Notes\n    -----\n    - Uses `ref_sim_info`, `ref_hpc_info`, and other reference pydantic models listed in `yaml_config.py` for validation.\n    - Ensures hierarchical consistency by iterating through all levels of the YAML structure.\n    \"\"\"\n    with open(yaml_file, 'r') as file:\n        sim_info = yaml.safe_load(file)\n\n    ref_sim_info.model_validate(sim_info)\n    if sim_info['hpc'] == 'yes':\n        ref_hpc_info.model_validate(sim_info['hpc_info'])\n    for hierarchy, hierarchy_info in enumerate(sim_info['hierarchies']): # loop for Hierarchy level\n        ref_hierarchy_info.model_validate(hierarchy_info)\n        for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n            ref_case_info.model_validate(case_info)\n            ref_geometry_info.model_validate(case_info['geometry_info'])\n            for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n                ref_exp_set_info.model_validate(exp_info)\n</code></pre>"},{"location":"reference/helpers/#helpers.load_csv_data","title":"<code>load_csv_data(csv_file, comm)</code>","text":"<p>Loads a CSV file and returns its content as a Pandas DataFrame.</p> <p>This function reads the specified CSV file and converts its content into a Pandas DataFrame. It handles common errors such as missing files, empty files, or parsing issues.</p>"},{"location":"reference/helpers/#helpers.load_csv_data--inputs","title":"Inputs","text":"<ul> <li>csv_file : str     Path to the CSV file to be loaded.</li> </ul>"},{"location":"reference/helpers/#helpers.load_csv_data--outputs","title":"Outputs","text":"<p>pandas.DataFrame or None     A DataFrame containing the content of the CSV file if successful, or None if an error occurs.</p> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def load_csv_data(csv_file, comm):\n    \"\"\"\n    Loads a CSV file and returns its content as a Pandas DataFrame.\n\n    This function reads the specified CSV file and converts its content into a Pandas DataFrame. It handles common errors such as missing files, empty files, or parsing issues.\n\n    Inputs\n    ----------\n    - **csv_file** : str\n        Path to the CSV file to be loaded.\n\n    Outputs\n    -------\n    **pandas.DataFrame or None**\n        A DataFrame containing the content of the CSV file if successful, or None if an error occurs.\n\"\"\"\n    try:\n        df = pd.read_csv(csv_file)\n        return df\n    except FileNotFoundError:\n        if comm.rank == 0:\n            print(f\"Error: The file '{csv_file}' was not found. Please check the file path.\")\n    except pd.errors.EmptyDataError:\n        if comm.rank == 0:\n            print(\"Error: The file is empty. Please check if data has been written correctly.\")\n    except pd.errors.ParserError:\n        if comm.rank == 0:\n            print(\"Error: The file could not be parsed. Please check the file format.\")\n    except Exception as e:\n        if comm.rank == 0:\n            print(f\"An unexpected error occurred: {e}\")\n    return None # In case of error, return none.\n</code></pre>"},{"location":"reference/helpers/#helpers.load_yaml_file","title":"<code>load_yaml_file(yaml_file, comm)</code>","text":"<p>Loads a YAML file and returns its content as a dictionary.</p> <p>This function attempts to read the specified YAML file and parse its content into a Python dictionary. If the file cannot be loaded due to errors, it provides a detailed error message.</p>"},{"location":"reference/helpers/#helpers.load_yaml_file--inputs","title":"Inputs","text":"<ul> <li>yaml_file : str     Path to the YAML file to be loaded.</li> </ul>"},{"location":"reference/helpers/#helpers.load_yaml_file--outputs","title":"Outputs","text":"<p>dict or None     A dictionary containing the content of the YAML file if successful, or None if an error occurs.</p> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def load_yaml_file(yaml_file, comm):\n    \"\"\"\n    Loads a YAML file and returns its content as a dictionary.\n\n    This function attempts to read the specified YAML file and parse its content into a Python dictionary. If the file cannot be loaded due to errors, it provides a detailed error message.\n\n    Inputs\n    ----------\n    - **yaml_file** : str\n        Path to the YAML file to be loaded.\n\n    Outputs\n    -------\n    **dict or None**\n        A dictionary containing the content of the YAML file if successful, or None if an error occurs.\n    \"\"\"\n    try:\n        # Attempt to open and read the YAML file\n        with open(yaml_file, 'r') as file:\n            dict_info = yaml.safe_load(file)\n        return dict_info\n    except FileNotFoundError:\n        # Handle the case where the YAML file is not found\n        if comm.rank == 0:  # Only the root process prints this error\n            print(f\"FileNotFoundError: The info file '{yaml_file}' was not found.\")\n    except yaml.YAMLError as ye:\n        # Errors in YAML parsing\n        if comm.rank == 0:  # Only the root process prints this error\n            print(f\"YAMLError: There was an issue reading '{yaml_file}'. Check the YAML formatting. Error: {ye}\")\n    except Exception as e:\n        # General error catch in case of other unexpected errors\n        if comm.rank == 0:  # Only the root process prints this error\n            print(f\"An unexpected error occurred while loading the info file: {e}\")\n    return None\n</code></pre>"},{"location":"reference/helpers/#helpers.write_job_script","title":"<code>write_job_script(hpc_info, out_dir, out_file, python_file_path, yaml_file_path)</code>","text":"<p>Generates a job script for running simulations on an HPC cluster.</p> <p>This function reads a Slurm job script template, updates it with specific HPC parameters and file paths, and saves the customized script to the output directory.</p>"},{"location":"reference/helpers/#helpers.write_job_script--inputs","title":"Inputs","text":"<ul> <li>hpc_info : dict     Dictionary containing HPC configuration details (e.g., cluster name, job name, nodes, tasks, and account).</li> <li>out_dir : str     Directory where the job script and output files will be saved.</li> <li>out_file : str     Name of the file to store job output.</li> <li>python_file_path : str     Path to the Python script to be executed by the job script.</li> <li>yaml_file_path : str     Path to the YAML file containing simulation information.</li> </ul>"},{"location":"reference/helpers/#helpers.write_job_script--outputs","title":"Outputs","text":"<ul> <li>str     Path to the generated job script.</li> </ul>"},{"location":"reference/helpers/#helpers.write_job_script--notes","title":"Notes","text":"<ul> <li>Supports customization for the GL cluster with Slurm job scheduling.</li> <li>Uses regex to update the job script with provided parameters.</li> <li>Ensures that the correct Python and YAML file paths are embedded in the job script.</li> </ul> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def write_job_script(hpc_info, out_dir, out_file, python_file_path, yaml_file_path):\n    \"\"\"\n    Generates a job script for running simulations on an HPC cluster.\n\n    This function reads a Slurm job script template, updates it with specific HPC parameters and file paths, and saves the customized script to the output directory.\n\n    Inputs\n    ------\n    - **hpc_info** : dict\n        Dictionary containing HPC configuration details (e.g., cluster name, job name, nodes, tasks, and account).\n    - **out_dir** : str\n        Directory where the job script and output files will be saved.\n    - **out_file** : str\n        Name of the file to store job output.\n    - **python_file_path** : str\n        Path to the Python script to be executed by the job script.\n    - **yaml_file_path** : str\n        Path to the YAML file containing simulation information.\n\n    Outputs\n    -------\n    - **str**\n        Path to the generated job script.\n\n    Notes\n    -----\n    - Supports customization for the GL cluster with Slurm job scheduling.\n    - Uses regex to update the job script with provided parameters.\n    - Ensures that the correct Python and YAML file paths are embedded in the job script.\n    \"\"\"\n    if hpc_info['cluster'] == 'GL':\n        # Set default time if not provided\n        job_time = hpc_info.get('time', '1:00:00')\n        mem_per_cpu = hpc_info.get('mem_per_cpu', '1000m')\n\n        # Fill in the template with values from hpc_info and other parameters\n        job_script = gl_job_script.format(\n            job_name=hpc_info['job_name'],\n            nodes=hpc_info['nodes'],\n            nproc=hpc_info['nproc'],\n            mem_per_cpu=mem_per_cpu,\n            time=job_time,\n            account_name=hpc_info['account_name'],\n            email_id=hpc_info['email_id'],\n            out_dir=out_dir,\n            out_file=out_file,\n            python_file_path=python_file_path,\n            yaml_file_path=yaml_file_path\n        )\n\n        # Define the path for the job script\n        job_script_path = f\"{out_dir}/{hpc_info['job_name']}.sh\"\n\n        # Save the script to the specified file\n        with open(job_script_path, \"w\") as file:\n            file.write(job_script)\n\n        return job_script_path\n</code></pre>"},{"location":"reference/helpers/#helpers.write_python_file","title":"<code>write_python_file(fname)</code>","text":"<p>Generates a Python script to run simulations on an HPC cluster.</p> <p>This function creates a Python script with predefined code to run simulations, including problem setup, execution, and post-processing.</p>"},{"location":"reference/helpers/#helpers.write_python_file--inputs","title":"Inputs","text":"<ul> <li>fname : str     Path where the Python script should be saved.</li> </ul>"},{"location":"reference/helpers/#helpers.write_python_file--notes","title":"Notes","text":"<ul> <li>The generated script uses argparse to accept input YAML files.</li> <li>It imports the <code>run_sim</code> class and runs the simulation using <code>run_problem</code> method.</li> </ul> Source code in <code>simulateTestCases/helpers.py</code> <pre><code>def write_python_file(fname):\n    \"\"\"\n    Generates a Python script to run simulations on an HPC cluster.\n\n    This function creates a Python script with predefined code to run simulations, including problem setup, execution, and post-processing.\n\n    Inputs\n    ----------\n    - **fname** : str\n        Path where the Python script should be saved.\n\n    Notes\n    -----\n    - The generated script uses argparse to accept input YAML files.\n    - It imports the `run_sim` class and runs the simulation using `run_problem` method.\n    \"\"\"\n    python_code = \"\"\"\nimport argparse\nfrom simulateTestCases.run_sim import run_sim\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--inputFile\", type=str)\nargs = parser.parse_args()\nsim = run_sim(args.inputFile) # Input the simulation info and output dir\nsim.run_problem() # Run the simulation\nsim.post_process() # Genrates plots comparing experimental data and simulated data and stores them\n        \"\"\"\n    # Open the file in write mode\n    with open(fname, \"w\") as file:\n        file.write(python_code)\n</code></pre>"},{"location":"reference/run_sim/","title":"run_sim","text":""},{"location":"reference/run_sim/#run_sim.Top","title":"<code>Top</code>","text":"<p>               Bases: <code>Multipoint</code></p> <p>Sets up an OpenMDAO problem using MPhys and ADflow for aerodynamic simulations.</p> <p>This class is designed to integrate OpenMDAO with MPhys and ADflow to perform aerodynamic simulations. It sets up the problem environment, manages inputs and outputs, and configures scenarios for simulation.</p>"},{"location":"reference/run_sim/#run_sim.Top--methods","title":"Methods","text":"<p>setup()     Initializes and sets up the required subsystems and scenarios.</p> <p>configure()     Configures the aerodynamic problem (e.g., reference area, chord, angle of attack) and connects design variables to the system.</p>"},{"location":"reference/run_sim/#run_sim.Top--inputs","title":"Inputs","text":"<ul> <li>case_info : dict     Dictionary containing geometry and configuration details for the case being analyzed.</li> <li>exp_info : dict     Dictionary with experimental conditions such as Mach number, Reynolds number, and temperature.</li> <li>aero_options : dict     ADflow solver parameters that control aerodynamic analysis.</li> </ul>"},{"location":"reference/run_sim/#run_sim.Top--outputs","title":"Outputs","text":"<p>None. This class directly modifies the OpenMDAO problem structure to include aerodynamic analysis subsystems.</p> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>class Top(Multipoint):\n\n    \"\"\"\n    Sets up an OpenMDAO problem using MPhys and ADflow for aerodynamic simulations.\n\n    This class is designed to integrate OpenMDAO with MPhys and ADflow to perform aerodynamic simulations. It sets up the problem environment, manages inputs and outputs, and configures scenarios for simulation.\n\n    Methods\n    --------\n    **setup()**\n        Initializes and sets up the required subsystems and scenarios.\n\n    **configure()**\n        Configures the aerodynamic problem (e.g., reference area, chord, angle of attack) and connects design variables to the system.\n\n    Inputs\n    -------\n    - **case_info** : dict\n        Dictionary containing geometry and configuration details for the case being analyzed.\n    - **exp_info** : dict\n        Dictionary with experimental conditions such as Mach number, Reynolds number, and temperature.\n    - **aero_options** : dict\n        ADflow solver parameters that control aerodynamic analysis.\n\n    Outputs\n    --------\n    None. This class directly modifies the OpenMDAO problem structure to include aerodynamic analysis subsystems.\n\n    \"\"\"\n\n    def __init__(self, case_info, exp_info, aero_options):\n        super().__init__()\n        self.case_info = case_info\n        self.exp_info = exp_info\n        self.aero_options = aero_options\n\n    def setup(self):\n\n        adflow_builder = ADflowBuilder(self.aero_options, scenario=\"aerodynamic\")\n        adflow_builder.initialize(self.comm)\n        adflow_builder.err_on_convergence_fail = True\n\n        ################################################################################\n        # MPHY setup\n        ################################################################################\n\n        # ivc to keep the top level DVs\n        self.add_subsystem(\"dvs\", om.IndepVarComp(), promotes=[\"*\"])\n\n        # create the mesh and cruise scenario because we only have one analysis point\n        self.add_subsystem(\"mesh\", adflow_builder.get_mesh_coordinate_subsystem())\n        self.mphys_add_scenario(\"cruise\", ScenarioAerodynamic(aero_builder=adflow_builder))\n        self.connect(\"mesh.x_aero0\", \"cruise.x_aero\")\n\n    def configure(self):\n        aoa = 0.0 # Set default Angle of attack\n\n        geometry_info = self.case_info['geometry_info'] # Load geometry info\n        chordRef = geometry_info['chordRef']\n        areaRef = geometry_info['areaRef']\n\n        ap0 = AeroProblem(\n            name=\"ap0\",\n            # Experimental Conditions \n            mach = self.exp_info['mach'], reynolds=self.exp_info['Re'], reynoldsLength=chordRef, T=self.exp_info['Temp'], \n            alpha=aoa,\n            # Geometry Info\n            areaRef=areaRef, \n            chordRef=chordRef, \n            evalFuncs=[\"cl\", \"cd\"]\n        )\n        ap0.addDV(\"alpha\", value=aoa, name=\"aoa\", units=\"deg\")\n\n\n        # set the aero problem in the coupling and post coupling groups\n        self.cruise.coupling.mphys_set_ap(ap0)\n        self.cruise.aero_post.mphys_set_ap(ap0)\n\n        # add dvs to ivc and connect\n        self.dvs.add_output(\"aoa\", val=aoa, units=\"deg\")\n        self.connect(\"aoa\", [\"cruise.coupling.aoa\", \"cruise.aero_post.aoa\"])\n</code></pre>"},{"location":"reference/run_sim/#run_sim.run_sim","title":"<code>run_sim</code>","text":"<p>Executes ADflow simulations using the <code>Top</code> class.</p> <p>This class sets up, runs, and post-processes aerodynamic simulations based on input parameters provided via a YAML configuration file. It validates the input, manages directories, and handles outputs, including plots and summary files.</p>"},{"location":"reference/run_sim/#run_sim.run_sim--methods","title":"Methods","text":"<p>run_problem()     Sets up and runs the OpenMDAO problem for all cases, hierarchies, and refinement levels.</p> <p>run()     Executes the simulation on either a local machine or an HPC system.</p> <p>post_process()     Generates plots comparing experimental data (if available) with ADflow simulation results.</p>"},{"location":"reference/run_sim/#run_sim.run_sim--inputs","title":"Inputs","text":"<ul> <li>info_file : str     Path to the YAML file containing simulation configuration and information.</li> </ul> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>class run_sim():\n    \"\"\"\n    Executes ADflow simulations using the `Top` class.\n\n    This class sets up, runs, and post-processes aerodynamic simulations based on input parameters provided via a YAML configuration file. It validates the input, manages directories, and handles outputs, including plots and summary files.\n\n    Methods\n    -------\n    **run_problem()**\n        Sets up and runs the OpenMDAO problem for all cases, hierarchies, and refinement levels.\n\n    **run()**\n        Executes the simulation on either a local machine or an HPC system.\n\n    **post_process()**\n        Generates plots comparing experimental data (if available) with ADflow simulation results.\n\n    Inputs\n    ----------\n    - **info_file** : str\n        Path to the YAML file containing simulation configuration and information.\n    \"\"\"\n\n    def __init__(self, info_file):\n        # Validate the input yaml file\n        check_input_yaml(info_file)\n        if comm.rank == 0:\n            print(f\"{'-' * 50}\")\n            print(\"YAML file validation is successful\")\n            print(f\"{'-' * 50}\")\n\n        self.info_file = info_file\n        self.sim_info = load_yaml_file(self.info_file, comm)\n        self.out_dir = self.sim_info['out_dir']\n        self.final_out_file = f\"{self.out_dir}/overall_sim_info.yaml\" # Setting the overall simulation info file.\n\n\n        # Create the output directory if it doesn't exist\n        if not os.path.exists(self.out_dir): \n            if comm.rank == 0:\n                os.makedirs(self.out_dir)\n\n    ################################################################################\n    # Code for running simulations\n    ################################################################################   \n    def run_problem(self):\n        \"\"\"\n        Sets up and runs the OpenMDAO problem for aerodynamic simulations.\n\n        This method iterates through all hierarchies, cases, refinement levels, and angles of attack defined in the input YAML file. For each combination, it sets up the OpenMDAO problem, runs the simulation, and stores the results.\n\n        Outputs\n        -------\n        - **A CSV file**:\n            Contains results for each angle of attack at the current refinement level.\n        - **A YAML file**:\n            Stores simulation data for each angle of attack in the corresponding directory.\n        - **A final YAML file**:\n            Summarizes all simulation results across hierarchies, cases, and refinement levels.\n\n        Notes\n        -----\n        This method ensures that:\n\n        - Existing successful simulations are skipped.\n        - Directories are created dynamically if they do not exist.\n        - Simulation results are saved in structured output files.\n        \"\"\"\n\n        # Store a copy of input YAML file in output directory\n        input_yaml_file = f\"{self.out_dir}/input_file.yaml\"\n        if comm.rank == 0:\n            with open(input_yaml_file, 'w') as input_yaml_handle:\n                yaml.dump(self.sim_info, input_yaml_handle, sort_keys=False)\n\n        sim_info_copy = copy.deepcopy(self.sim_info) # Copying to run the loop\n        sim_out_info = copy.deepcopy(self.sim_info) # Copying to write the output YAML file\n        start_time = time.time()\n        start_wall_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n        for hierarchy, hierarchy_info in enumerate(sim_info_copy['hierarchies']): # loop for Hierarchy level\n\n            for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n\n                aero_options = default_aero_options.copy()\n                aero_options.update(case_info['solver_parameters']) # Update ADflow solver parameters\n\n                for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n\n                    if comm.rank == 0:\n                        print(f\"{'#' * 30}\")\n                        print(f\"{'SIMULATION INFO':^30}\")\n                        print(f\"{'#' * 30}\")\n                        print(f\"{'Hierarchy':&lt;20}: {hierarchy_info['name']}\")\n                        print(f\"{'Case Name':&lt;20}: {case_info['name']}\")\n                        print(f\"{'Experimental Condition':&lt;20}: {exp_set}\")\n                        print(f\"{'Reynolds Number (Re)':&lt;20}: {exp_info['Re']}\")\n                        print(f\"{'Mach Number':&lt;20}: {exp_info['mach']}\")\n                        print(f\"{'=' * 30}\")\n\n                    # Extract the Angle of attacks for which the simulation has to be run\n                    aoa_list = exp_info['aoa_list']\n\n                    exp_sim_info = {} # Creating experimental level sim info dictionary for overall sim info file\n\n                    for ii, mesh_file in enumerate(case_info['mesh_files']): # Loop for refinement levels\n\n                        refinement_level = f\"L{ii}\"\n                        CLList = []\n                        CDList = []\n                        TList = []\n                        FList = [] # Fail flag list\n\n                        refinement_level_dict = {} # Creating refinement level sim info dictionary for overall sim info file\n\n                        # Update Grid file\n                        aero_options['gridFile'] = f\"{case_info['meshes_folder_path']}/{mesh_file}\"\n\n\n                        for aoa in aoa_list: # loop for angles of attack\n\n                            # Date\n                            current_date = date.today()\n                            date_string = current_date.strftime(\"%Y-%m-%d\")\n\n                            # Define output directory -- Written to store in the parent directory\n                            output_dir = f\"{self.out_dir}/{hierarchy_info['name']}/{case_info['name']}/exp_set_{exp_set}/{refinement_level}/aoa_{aoa}\"\n                            aero_options['outputDirectory'] = output_dir\n\n                            # name of the simulation info file at the aoa level directory\n                            aoa_info_file = f\"{output_dir}/aoa_{aoa}.yaml\" \n\n\n                            aoa_level_dict = {} # Creating aoa level sim info dictionary for overall sim info file\n\n                            ################################################################################\n                            # OpenMDAO setup\n                            ################################################################################\n\n                            os.environ[\"OPENMDAO_REPORTS\"]=\"0\" # Do this to disable report generation by OpenMDAO\n\n                            prob = om.Problem()\n                            prob.model = Top(case_info, exp_info, aero_options)\n\n                            # Checking for existing sucessful simualtion info, \n                            if os.path.exists(output_dir):\n                                try:\n                                    with open(aoa_info_file, 'r') as aoa_file:\n                                        aoa_sim_info = yaml.safe_load(aoa_file)\n                                    fail_flag = aoa_sim_info['fail_flag']\n                                    if fail_flag == 0:\n                                        CLList.append(aoa_sim_info['cl'])\n                                        CDList.append(aoa_sim_info['cd'])\n                                        TList.append(float(aoa_sim_info['wall_time'].replace(\" sec\", \"\")))\n                                        FList.append(fail_flag)\n\n                                        # To Store in the overall simulation out file in case of skipping\n                                        aoa_level_dict = {\n                                            'cl': float(aoa_sim_info['cl']),\n                                            'cd': float(aoa_sim_info['cd']),\n                                            'wall_time': aoa_sim_info['wall_time'],\n                                            'fail_flag': int(fail_flag),\n                                            'out_dir': output_dir,\n                                        }\n                                        refinement_level_dict[f\"aoa_{aoa}\"] = aoa_level_dict\n\n                                        if comm.rank == 0:\n                                            print(f\"{'-'*50}\")\n                                            print(f\"{'NOTICE':^50}\")\n                                            print(f\"{'-'*50}\")\n                                            print(f\"Skipping Angle of Attack (AoA): {float(aoa):&lt;5} | Reason: Existing successful simulation found\")\n                                            print(f\"{'-'*50}\")\n                                        continue # Continue to next loop if there exists a successful simulation\n                                except:\n                                    fail_flag = 1\n                            elif not os.path.exists(output_dir): # Create the directory if it doesn't exist\n                                if comm.rank == 0:\n                                    os.makedirs(output_dir)\n\n\n                            if comm.rank == 0:\n                                print(f\"{'-'*50}\")\n                                print(f\"Starting Angle of Attack (AoA): {float(aoa):&lt;5}\")\n                                print(f\"{'-'*50}\")\n                            # Setup the problem\n                            prob.setup()\n\n                            # Set the angle\n                            prob[\"aoa\"] = float(aoa)\n\n                            om.n2(prob, show_browser=False, outfile=f\"{output_dir}/mphys_aero.html\")\n\n                            # Run the model\n                            aoa_start_time = time.time() # Stote the start time\n                            try:\n                                prob.run_model()\n                                fail_flag = 0\n                            except:\n                                fail_flag = 1\n\n                            aoa_end_time = time.time() # Store the end time\n                            aoa_run_time = aoa_end_time - aoa_start_time # Compute the run time\n\n                            prob.model.list_inputs(units=True)\n                            prob.model.list_outputs(units=True)\n\n                            # Store a Yaml file at this level\n                            aoa_out_dic = {\n                                'case': case_info['name'],\n                                'exp_info': exp_info,\n                                'mesh_file_used': f\"{case_info['meshes_folder_path']}/{mesh_file}\",\n                                'AOA': float(aoa),\n                                'cl': float(prob[\"cruise.aero_post.cl\"][0]),\n                                'cd': float(prob[\"cruise.aero_post.cd\"][0]),\n                                'refinement_level': refinement_level,\n                                'wall_time': f\"{aoa_run_time:.2f} sec\",\n                                'fail_flag': int(fail_flag),\n                                'out_dir': output_dir,\n                            }\n                            with open(aoa_info_file, 'w') as interim_out_yaml:\n                                yaml.dump(aoa_out_dic, interim_out_yaml, sort_keys=False)\n\n                            # To Store in the overall simulation out file\n                            aoa_level_dict = {\n                                'cl': float(prob[\"cruise.aero_post.cl\"][0]),\n                                'cd': float(prob[\"cruise.aero_post.cd\"][0]),\n                                'wall_time': f\"{aoa_run_time:.2f} sec\",\n                                'fail_flag': int(fail_flag),\n                                'out_dir': output_dir,\n                            }\n                            refinement_level_dict[f\"aoa_{aoa}\"] = aoa_level_dict\n\n                            # Adding cl, cd, wall time, Fail flags to their respective lists to create the csv file at refinement level\n                            CLList.append(float(prob[\"cruise.aero_post.cl\"][0]))\n                            CDList.append(float(prob[\"cruise.aero_post.cd\"][0]))\n                            TList.append(aoa_run_time)\n                            FList.append(fail_flag)\n\n                        # Write simulation results to a csv file\n                        refinement_level_data = {\n                            \"Alpha\": [f\"{alpha:6.2f}\" for alpha in aoa_list],\n                            \"CL\": [f\"{cl:8.4f}\" for cl in CLList],\n                            \"CD\": [f\"{cd:8.4f}\" for cd in CDList],\n                            \"FFlag\": [f\"{int(FF):12f}\" for FF in FList],\n                            \"WTime\": [f\"{wall_time:10.2f}\" for wall_time in TList]\n                        }\n                        df = pd.DataFrame(refinement_level_data) # Create a panda DataFrame\n\n                        # Define the output file path\n                        refinement_level_dir = os.path.dirname(output_dir)\n                        ADflow_out_file = f\"{refinement_level_dir}/ADflow_output.csv\"\n\n                        # Write the DataFrame to a CSV file\n                        df.to_csv(ADflow_out_file, index=False)\n\n                        # Add csv file location to the overall simulation out file\n                        refinement_level_dict['csv_file'] = ADflow_out_file\n                        refinement_level_dict['refinement_out_dir'] = refinement_level_dir\n\n                        # Add refinement level dict to exp level dict\n                        exp_sim_info[f\"{refinement_level}\"] = refinement_level_dict\n\n                    # Add experimental level simulation to the overall simulation out file\n                    exp_out_dir = os.path.dirname(refinement_level_dir)\n                    exp_sim_info['exp_set_out_dir'] = exp_out_dir\n                    sim_out_info['hierarchies'][hierarchy]['cases'][case]['exp_sets'][exp_set]['sim_info'] = exp_sim_info\n\n        end_time = time.time()\n        end_wall_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        net_run_time = end_time - start_time\n        sim_out_info['overall_sim_info'] = {\n            'start_time': start_wall_time,\n            'end_time': end_wall_time,\n            'total_wall_time': f\"{net_run_time:.2f} sec\"\n        }\n\n        # Store the final simulation out file.\n        if comm.rank == 0:\n            with open(self.final_out_file, 'w') as final_out_yaml_handle:\n                yaml.dump(sim_out_info, final_out_yaml_handle, sort_keys=False)\n        comm.Barrier()\n\n    ################################################################################\n    # Code for user to run simulations\n    ################################################################################\n    def run(self):\n        \"\"\"\n        Executes the simulation on either a local machine or an HPC system.\n\n        This method checks the simulation settings from the input YAML file. Based on the `hpc` flag, it either runs the simulation locally or generates an HPC job script for execution.\n\n        Notes\n        -----\n        - For local execution (`hpc: no`), it directly calls `run_problem()`.\n        - For HPC execution (`hpc: yes`), it creates a Python file and a job script, then submits the job using `sbatch`.\n        \"\"\"\n        sim_info_copy = copy.deepcopy(self.sim_info)\n        if sim_info_copy['hpc'] == \"no\":\n            self.run_problem()\n        elif sim_info_copy['hpc'] == \"yes\":\n            python_file_path = f\"{self.out_dir}/run_sim.py\"\n            slrum_out_file = f\"overall_sim_out.txt\"\n            # Create a python file to run\n            write_python_file(python_file_path)\n            # Create a job script to run\n            job_script_path = write_job_script(sim_info_copy['hpc_info'], self.out_dir, slrum_out_file, python_file_path, self.info_file)\n\n            subprocess.run([\"sbatch\", job_script_path])\n\n    ################################################################################\n    # Code for Post Processing\n    ################################################################################\n\n    def post_process(self):\n        \"\"\"\n        Generates plots comparing experimental data with ADflow simulation results.\n\n        This method creates comparison plots for each experimental condition and refinement level. The plots include `CL` (Lift Coefficient) and `CD` (Drag Coefficient) against the angle of attack (Alpha). Experimental data, if provided, is included in the plots for validation.\n\n        Outputs\n        -------\n        - *PNG plots*:\n            Stored in the experimental condition directory for each hierarchy and case.\n\n        Notes\n        -----\n        - Experimental data is optional. If not provided, only simulation results are plotted.\n        - Plots are saved with clear labels and legends for easy interpretation.\n        \"\"\"\n        sim_out_info = load_yaml_file(self.final_out_file, comm)\n\n        for hierarchy, hierarchy_info in enumerate(sim_out_info['hierarchies']): # loop for Hierarchy level\n            for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n                for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n\n                    # Plot setup\n                    fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n                    fig.suptitle('Comparison between ADflow Simulation and Experimental Data')\n\n                    # Load Experimental Data\n                    try:\n                        exp_data = load_csv_data(exp_info['exp_data'], comm)\n                    except:\n                        if comm.rank == 0:\n                            print(f\"Warning: Experimental data location is not specified or the data is not readable.\")\n                        exp_data = None\n\n                    if exp_data is not None: # Only plot if data loaded successfully\n                        exp_data.columns = exp_data.columns.str.strip()  # Clean column names\n\n                        # Convert to numeric to avoid plotting issues\n                        exp_data['Alpha'] = pd.to_numeric(exp_data['Alpha'], errors='coerce')\n                        exp_data['CL'] = pd.to_numeric(exp_data['CL'], errors='coerce')\n                        exp_data['CD'] = pd.to_numeric(exp_data['CD'], errors='coerce')\n                        exp_data = exp_data.dropna()  # Drop rows with missing data\n\n                        axs[0].plot(exp_data['Alpha'], exp_data['CL'], label='Experimental', color='black', linestyle='--', marker='o')\n                        axs[1].plot(exp_data['Alpha'], exp_data['CD'], label='Experimental', color='black', linestyle='--', marker='o')\n\n                    else:\n                        if comm.rank == 0:\n                            print(\"Continuing to plot without experimental data.\")\n\n                    num_levels = len(case_info['mesh_files'])  # Total refinement levels\n                    colors = cm.viridis(np.linspace(0, 1, num_levels))  # Generate unique colors for each level\n                    # Load Simulated Data\n                    exp_out_dir = exp_info['sim_info']['exp_set_out_dir']\n                    sim_data = {}\n                    for ii, mesh_file in enumerate(case_info['mesh_files']): # Loop for refinement levels\n                        refinement_level_dir = f\"{exp_out_dir}/L{ii}\"\n                        ADflow_out_file = f\"{refinement_level_dir}/ADflow_output.csv\"\n                        sim_data = load_csv_data(ADflow_out_file, comm)\n                        if sim_data is not None:  # Only plot if data loaded successfully\n                            label = f\"L{ii}\"\n                            axs[0].plot(sim_data['Alpha'], sim_data['CL'], label=label, color=colors[ii], linestyle='-', marker='s') # Plot CL vs Alpha for this refinement level\n                            axs[1].plot(sim_data['Alpha'], sim_data['CD'], label=label, color=colors[ii], linestyle='-', marker='s') # Plot CD vs Alpha for this refinement level\n\n                    # Setting titles, labels, and legends\n                    axs[0].set_title('$C_L$ vs Alpha')\n                    axs[0].set_xlabel('Alpha (deg)')\n                    axs[0].set_ylabel('$C_L$')\n                    axs[0].legend()\n                    axs[0].grid(True)\n\n                    axs[1].set_title('$C_D$ vs Alpha')\n                    axs[1].set_xlabel('Alpha (deg)')\n                    axs[1].set_ylabel('$C_D$')\n                    axs[1].legend()\n                    axs[1].grid(True)\n\n                    plt.tight_layout(rect=[0, 0, 1, 0.96])  # Adjust layout to fit title\n                    plt.savefig(f\"{exp_out_dir}/ADflow_Results.png\")\n</code></pre>"},{"location":"reference/run_sim/#run_sim.run_sim.post_process","title":"<code>post_process()</code>","text":"<p>Generates plots comparing experimental data with ADflow simulation results.</p> <p>This method creates comparison plots for each experimental condition and refinement level. The plots include <code>CL</code> (Lift Coefficient) and <code>CD</code> (Drag Coefficient) against the angle of attack (Alpha). Experimental data, if provided, is included in the plots for validation.</p>"},{"location":"reference/run_sim/#run_sim.run_sim.post_process--outputs","title":"Outputs","text":"<ul> <li>PNG plots:     Stored in the experimental condition directory for each hierarchy and case.</li> </ul>"},{"location":"reference/run_sim/#run_sim.run_sim.post_process--notes","title":"Notes","text":"<ul> <li>Experimental data is optional. If not provided, only simulation results are plotted.</li> <li>Plots are saved with clear labels and legends for easy interpretation.</li> </ul> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>def post_process(self):\n    \"\"\"\n    Generates plots comparing experimental data with ADflow simulation results.\n\n    This method creates comparison plots for each experimental condition and refinement level. The plots include `CL` (Lift Coefficient) and `CD` (Drag Coefficient) against the angle of attack (Alpha). Experimental data, if provided, is included in the plots for validation.\n\n    Outputs\n    -------\n    - *PNG plots*:\n        Stored in the experimental condition directory for each hierarchy and case.\n\n    Notes\n    -----\n    - Experimental data is optional. If not provided, only simulation results are plotted.\n    - Plots are saved with clear labels and legends for easy interpretation.\n    \"\"\"\n    sim_out_info = load_yaml_file(self.final_out_file, comm)\n\n    for hierarchy, hierarchy_info in enumerate(sim_out_info['hierarchies']): # loop for Hierarchy level\n        for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n            for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n\n                # Plot setup\n                fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n                fig.suptitle('Comparison between ADflow Simulation and Experimental Data')\n\n                # Load Experimental Data\n                try:\n                    exp_data = load_csv_data(exp_info['exp_data'], comm)\n                except:\n                    if comm.rank == 0:\n                        print(f\"Warning: Experimental data location is not specified or the data is not readable.\")\n                    exp_data = None\n\n                if exp_data is not None: # Only plot if data loaded successfully\n                    exp_data.columns = exp_data.columns.str.strip()  # Clean column names\n\n                    # Convert to numeric to avoid plotting issues\n                    exp_data['Alpha'] = pd.to_numeric(exp_data['Alpha'], errors='coerce')\n                    exp_data['CL'] = pd.to_numeric(exp_data['CL'], errors='coerce')\n                    exp_data['CD'] = pd.to_numeric(exp_data['CD'], errors='coerce')\n                    exp_data = exp_data.dropna()  # Drop rows with missing data\n\n                    axs[0].plot(exp_data['Alpha'], exp_data['CL'], label='Experimental', color='black', linestyle='--', marker='o')\n                    axs[1].plot(exp_data['Alpha'], exp_data['CD'], label='Experimental', color='black', linestyle='--', marker='o')\n\n                else:\n                    if comm.rank == 0:\n                        print(\"Continuing to plot without experimental data.\")\n\n                num_levels = len(case_info['mesh_files'])  # Total refinement levels\n                colors = cm.viridis(np.linspace(0, 1, num_levels))  # Generate unique colors for each level\n                # Load Simulated Data\n                exp_out_dir = exp_info['sim_info']['exp_set_out_dir']\n                sim_data = {}\n                for ii, mesh_file in enumerate(case_info['mesh_files']): # Loop for refinement levels\n                    refinement_level_dir = f\"{exp_out_dir}/L{ii}\"\n                    ADflow_out_file = f\"{refinement_level_dir}/ADflow_output.csv\"\n                    sim_data = load_csv_data(ADflow_out_file, comm)\n                    if sim_data is not None:  # Only plot if data loaded successfully\n                        label = f\"L{ii}\"\n                        axs[0].plot(sim_data['Alpha'], sim_data['CL'], label=label, color=colors[ii], linestyle='-', marker='s') # Plot CL vs Alpha for this refinement level\n                        axs[1].plot(sim_data['Alpha'], sim_data['CD'], label=label, color=colors[ii], linestyle='-', marker='s') # Plot CD vs Alpha for this refinement level\n\n                # Setting titles, labels, and legends\n                axs[0].set_title('$C_L$ vs Alpha')\n                axs[0].set_xlabel('Alpha (deg)')\n                axs[0].set_ylabel('$C_L$')\n                axs[0].legend()\n                axs[0].grid(True)\n\n                axs[1].set_title('$C_D$ vs Alpha')\n                axs[1].set_xlabel('Alpha (deg)')\n                axs[1].set_ylabel('$C_D$')\n                axs[1].legend()\n                axs[1].grid(True)\n\n                plt.tight_layout(rect=[0, 0, 1, 0.96])  # Adjust layout to fit title\n                plt.savefig(f\"{exp_out_dir}/ADflow_Results.png\")\n</code></pre>"},{"location":"reference/run_sim/#run_sim.run_sim.run","title":"<code>run()</code>","text":"<p>Executes the simulation on either a local machine or an HPC system.</p> <p>This method checks the simulation settings from the input YAML file. Based on the <code>hpc</code> flag, it either runs the simulation locally or generates an HPC job script for execution.</p>"},{"location":"reference/run_sim/#run_sim.run_sim.run--notes","title":"Notes","text":"<ul> <li>For local execution (<code>hpc: no</code>), it directly calls <code>run_problem()</code>.</li> <li>For HPC execution (<code>hpc: yes</code>), it creates a Python file and a job script, then submits the job using <code>sbatch</code>.</li> </ul> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>def run(self):\n    \"\"\"\n    Executes the simulation on either a local machine or an HPC system.\n\n    This method checks the simulation settings from the input YAML file. Based on the `hpc` flag, it either runs the simulation locally or generates an HPC job script for execution.\n\n    Notes\n    -----\n    - For local execution (`hpc: no`), it directly calls `run_problem()`.\n    - For HPC execution (`hpc: yes`), it creates a Python file and a job script, then submits the job using `sbatch`.\n    \"\"\"\n    sim_info_copy = copy.deepcopy(self.sim_info)\n    if sim_info_copy['hpc'] == \"no\":\n        self.run_problem()\n    elif sim_info_copy['hpc'] == \"yes\":\n        python_file_path = f\"{self.out_dir}/run_sim.py\"\n        slrum_out_file = f\"overall_sim_out.txt\"\n        # Create a python file to run\n        write_python_file(python_file_path)\n        # Create a job script to run\n        job_script_path = write_job_script(sim_info_copy['hpc_info'], self.out_dir, slrum_out_file, python_file_path, self.info_file)\n\n        subprocess.run([\"sbatch\", job_script_path])\n</code></pre>"},{"location":"reference/run_sim/#run_sim.run_sim.run_problem","title":"<code>run_problem()</code>","text":"<p>Sets up and runs the OpenMDAO problem for aerodynamic simulations.</p> <p>This method iterates through all hierarchies, cases, refinement levels, and angles of attack defined in the input YAML file. For each combination, it sets up the OpenMDAO problem, runs the simulation, and stores the results.</p>"},{"location":"reference/run_sim/#run_sim.run_sim.run_problem--outputs","title":"Outputs","text":"<ul> <li>A CSV file:     Contains results for each angle of attack at the current refinement level.</li> <li>A YAML file:     Stores simulation data for each angle of attack in the corresponding directory.</li> <li>A final YAML file:     Summarizes all simulation results across hierarchies, cases, and refinement levels.</li> </ul>"},{"location":"reference/run_sim/#run_sim.run_sim.run_problem--notes","title":"Notes","text":"<p>This method ensures that:</p> <ul> <li>Existing successful simulations are skipped.</li> <li>Directories are created dynamically if they do not exist.</li> <li>Simulation results are saved in structured output files.</li> </ul> Source code in <code>simulateTestCases/run_sim.py</code> <pre><code>def run_problem(self):\n    \"\"\"\n    Sets up and runs the OpenMDAO problem for aerodynamic simulations.\n\n    This method iterates through all hierarchies, cases, refinement levels, and angles of attack defined in the input YAML file. For each combination, it sets up the OpenMDAO problem, runs the simulation, and stores the results.\n\n    Outputs\n    -------\n    - **A CSV file**:\n        Contains results for each angle of attack at the current refinement level.\n    - **A YAML file**:\n        Stores simulation data for each angle of attack in the corresponding directory.\n    - **A final YAML file**:\n        Summarizes all simulation results across hierarchies, cases, and refinement levels.\n\n    Notes\n    -----\n    This method ensures that:\n\n    - Existing successful simulations are skipped.\n    - Directories are created dynamically if they do not exist.\n    - Simulation results are saved in structured output files.\n    \"\"\"\n\n    # Store a copy of input YAML file in output directory\n    input_yaml_file = f\"{self.out_dir}/input_file.yaml\"\n    if comm.rank == 0:\n        with open(input_yaml_file, 'w') as input_yaml_handle:\n            yaml.dump(self.sim_info, input_yaml_handle, sort_keys=False)\n\n    sim_info_copy = copy.deepcopy(self.sim_info) # Copying to run the loop\n    sim_out_info = copy.deepcopy(self.sim_info) # Copying to write the output YAML file\n    start_time = time.time()\n    start_wall_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    for hierarchy, hierarchy_info in enumerate(sim_info_copy['hierarchies']): # loop for Hierarchy level\n\n        for case, case_info in enumerate(hierarchy_info['cases']): # loop for cases in hierarchy\n\n            aero_options = default_aero_options.copy()\n            aero_options.update(case_info['solver_parameters']) # Update ADflow solver parameters\n\n            for exp_set, exp_info in enumerate(case_info['exp_sets']): # loop for experimental datasets that may present\n\n                if comm.rank == 0:\n                    print(f\"{'#' * 30}\")\n                    print(f\"{'SIMULATION INFO':^30}\")\n                    print(f\"{'#' * 30}\")\n                    print(f\"{'Hierarchy':&lt;20}: {hierarchy_info['name']}\")\n                    print(f\"{'Case Name':&lt;20}: {case_info['name']}\")\n                    print(f\"{'Experimental Condition':&lt;20}: {exp_set}\")\n                    print(f\"{'Reynolds Number (Re)':&lt;20}: {exp_info['Re']}\")\n                    print(f\"{'Mach Number':&lt;20}: {exp_info['mach']}\")\n                    print(f\"{'=' * 30}\")\n\n                # Extract the Angle of attacks for which the simulation has to be run\n                aoa_list = exp_info['aoa_list']\n\n                exp_sim_info = {} # Creating experimental level sim info dictionary for overall sim info file\n\n                for ii, mesh_file in enumerate(case_info['mesh_files']): # Loop for refinement levels\n\n                    refinement_level = f\"L{ii}\"\n                    CLList = []\n                    CDList = []\n                    TList = []\n                    FList = [] # Fail flag list\n\n                    refinement_level_dict = {} # Creating refinement level sim info dictionary for overall sim info file\n\n                    # Update Grid file\n                    aero_options['gridFile'] = f\"{case_info['meshes_folder_path']}/{mesh_file}\"\n\n\n                    for aoa in aoa_list: # loop for angles of attack\n\n                        # Date\n                        current_date = date.today()\n                        date_string = current_date.strftime(\"%Y-%m-%d\")\n\n                        # Define output directory -- Written to store in the parent directory\n                        output_dir = f\"{self.out_dir}/{hierarchy_info['name']}/{case_info['name']}/exp_set_{exp_set}/{refinement_level}/aoa_{aoa}\"\n                        aero_options['outputDirectory'] = output_dir\n\n                        # name of the simulation info file at the aoa level directory\n                        aoa_info_file = f\"{output_dir}/aoa_{aoa}.yaml\" \n\n\n                        aoa_level_dict = {} # Creating aoa level sim info dictionary for overall sim info file\n\n                        ################################################################################\n                        # OpenMDAO setup\n                        ################################################################################\n\n                        os.environ[\"OPENMDAO_REPORTS\"]=\"0\" # Do this to disable report generation by OpenMDAO\n\n                        prob = om.Problem()\n                        prob.model = Top(case_info, exp_info, aero_options)\n\n                        # Checking for existing sucessful simualtion info, \n                        if os.path.exists(output_dir):\n                            try:\n                                with open(aoa_info_file, 'r') as aoa_file:\n                                    aoa_sim_info = yaml.safe_load(aoa_file)\n                                fail_flag = aoa_sim_info['fail_flag']\n                                if fail_flag == 0:\n                                    CLList.append(aoa_sim_info['cl'])\n                                    CDList.append(aoa_sim_info['cd'])\n                                    TList.append(float(aoa_sim_info['wall_time'].replace(\" sec\", \"\")))\n                                    FList.append(fail_flag)\n\n                                    # To Store in the overall simulation out file in case of skipping\n                                    aoa_level_dict = {\n                                        'cl': float(aoa_sim_info['cl']),\n                                        'cd': float(aoa_sim_info['cd']),\n                                        'wall_time': aoa_sim_info['wall_time'],\n                                        'fail_flag': int(fail_flag),\n                                        'out_dir': output_dir,\n                                    }\n                                    refinement_level_dict[f\"aoa_{aoa}\"] = aoa_level_dict\n\n                                    if comm.rank == 0:\n                                        print(f\"{'-'*50}\")\n                                        print(f\"{'NOTICE':^50}\")\n                                        print(f\"{'-'*50}\")\n                                        print(f\"Skipping Angle of Attack (AoA): {float(aoa):&lt;5} | Reason: Existing successful simulation found\")\n                                        print(f\"{'-'*50}\")\n                                    continue # Continue to next loop if there exists a successful simulation\n                            except:\n                                fail_flag = 1\n                        elif not os.path.exists(output_dir): # Create the directory if it doesn't exist\n                            if comm.rank == 0:\n                                os.makedirs(output_dir)\n\n\n                        if comm.rank == 0:\n                            print(f\"{'-'*50}\")\n                            print(f\"Starting Angle of Attack (AoA): {float(aoa):&lt;5}\")\n                            print(f\"{'-'*50}\")\n                        # Setup the problem\n                        prob.setup()\n\n                        # Set the angle\n                        prob[\"aoa\"] = float(aoa)\n\n                        om.n2(prob, show_browser=False, outfile=f\"{output_dir}/mphys_aero.html\")\n\n                        # Run the model\n                        aoa_start_time = time.time() # Stote the start time\n                        try:\n                            prob.run_model()\n                            fail_flag = 0\n                        except:\n                            fail_flag = 1\n\n                        aoa_end_time = time.time() # Store the end time\n                        aoa_run_time = aoa_end_time - aoa_start_time # Compute the run time\n\n                        prob.model.list_inputs(units=True)\n                        prob.model.list_outputs(units=True)\n\n                        # Store a Yaml file at this level\n                        aoa_out_dic = {\n                            'case': case_info['name'],\n                            'exp_info': exp_info,\n                            'mesh_file_used': f\"{case_info['meshes_folder_path']}/{mesh_file}\",\n                            'AOA': float(aoa),\n                            'cl': float(prob[\"cruise.aero_post.cl\"][0]),\n                            'cd': float(prob[\"cruise.aero_post.cd\"][0]),\n                            'refinement_level': refinement_level,\n                            'wall_time': f\"{aoa_run_time:.2f} sec\",\n                            'fail_flag': int(fail_flag),\n                            'out_dir': output_dir,\n                        }\n                        with open(aoa_info_file, 'w') as interim_out_yaml:\n                            yaml.dump(aoa_out_dic, interim_out_yaml, sort_keys=False)\n\n                        # To Store in the overall simulation out file\n                        aoa_level_dict = {\n                            'cl': float(prob[\"cruise.aero_post.cl\"][0]),\n                            'cd': float(prob[\"cruise.aero_post.cd\"][0]),\n                            'wall_time': f\"{aoa_run_time:.2f} sec\",\n                            'fail_flag': int(fail_flag),\n                            'out_dir': output_dir,\n                        }\n                        refinement_level_dict[f\"aoa_{aoa}\"] = aoa_level_dict\n\n                        # Adding cl, cd, wall time, Fail flags to their respective lists to create the csv file at refinement level\n                        CLList.append(float(prob[\"cruise.aero_post.cl\"][0]))\n                        CDList.append(float(prob[\"cruise.aero_post.cd\"][0]))\n                        TList.append(aoa_run_time)\n                        FList.append(fail_flag)\n\n                    # Write simulation results to a csv file\n                    refinement_level_data = {\n                        \"Alpha\": [f\"{alpha:6.2f}\" for alpha in aoa_list],\n                        \"CL\": [f\"{cl:8.4f}\" for cl in CLList],\n                        \"CD\": [f\"{cd:8.4f}\" for cd in CDList],\n                        \"FFlag\": [f\"{int(FF):12f}\" for FF in FList],\n                        \"WTime\": [f\"{wall_time:10.2f}\" for wall_time in TList]\n                    }\n                    df = pd.DataFrame(refinement_level_data) # Create a panda DataFrame\n\n                    # Define the output file path\n                    refinement_level_dir = os.path.dirname(output_dir)\n                    ADflow_out_file = f\"{refinement_level_dir}/ADflow_output.csv\"\n\n                    # Write the DataFrame to a CSV file\n                    df.to_csv(ADflow_out_file, index=False)\n\n                    # Add csv file location to the overall simulation out file\n                    refinement_level_dict['csv_file'] = ADflow_out_file\n                    refinement_level_dict['refinement_out_dir'] = refinement_level_dir\n\n                    # Add refinement level dict to exp level dict\n                    exp_sim_info[f\"{refinement_level}\"] = refinement_level_dict\n\n                # Add experimental level simulation to the overall simulation out file\n                exp_out_dir = os.path.dirname(refinement_level_dir)\n                exp_sim_info['exp_set_out_dir'] = exp_out_dir\n                sim_out_info['hierarchies'][hierarchy]['cases'][case]['exp_sets'][exp_set]['sim_info'] = exp_sim_info\n\n    end_time = time.time()\n    end_wall_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    net_run_time = end_time - start_time\n    sim_out_info['overall_sim_info'] = {\n        'start_time': start_wall_time,\n        'end_time': end_wall_time,\n        'total_wall_time': f\"{net_run_time:.2f} sec\"\n    }\n\n    # Store the final simulation out file.\n    if comm.rank == 0:\n        with open(self.final_out_file, 'w') as final_out_yaml_handle:\n            yaml.dump(sim_out_info, final_out_yaml_handle, sort_keys=False)\n    comm.Barrier()\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#utils.get_sim_data","title":"<code>get_sim_data(info_file, run_flag=RunFlag.skip)</code>","text":"<p>Generates a dictionary containing simulation data organized hierarchically.</p> <p>This function processes a YAML file with simulation information and creates a nested dictionary (<code>sim_data</code>) with details about simulation hierarchies, cases, experiment sets, refinement levels, and angles of attack. It also provides an option to run a simulation if the required data does not exist.</p>"},{"location":"reference/utils/#utils.get_sim_data--inputs","title":"Inputs","text":"<ul> <li>info_file : str     Path to the input YAML file containing simulation information or configuration.</li> <li>run_flag : RunFlag, optional     Enum to determine behavior if required simulation data is not found:<ul> <li><code>RunFlag.skip</code> (default): Exit without running the simulation.</li> <li><code>RunFlag.run</code>: Run the simulation and populate the data.</li> </ul> </li> </ul>"},{"location":"reference/utils/#utils.get_sim_data--outputs","title":"Outputs","text":"<p>sim_data: dict     A dictionary contating simulation data.</p> Source code in <code>simulateTestCases/utils.py</code> <pre><code>def get_sim_data(info_file, run_flag=RunFlag.skip):\n    \"\"\"\n    Generates a dictionary containing simulation data organized hierarchically.\n\n    This function processes a YAML file with simulation information and creates a\n    nested dictionary (`sim_data`) with details about simulation hierarchies, cases,\n    experiment sets, refinement levels, and angles of attack. It also provides an\n    option to run a simulation if the required data does not exist.\n\n    Inputs\n    ------\n    - **info_file** : str\n        Path to the input YAML file containing simulation information or configuration.\n    - **run_flag** : RunFlag, optional\n        Enum to determine behavior if required simulation data is not found:\n        - `RunFlag.skip` (default): Exit without running the simulation.\n        - `RunFlag.run`: Run the simulation and populate the data.\n\n    Outputs\n    -------\n    **sim_data**: dict\n        A dictionary contating simulation data.\n    \"\"\"\n    check_input_yaml(info_file)\n    if comm.rank == 0:\n        print(f\"{'-' * 50}\")\n        print(\"YAML file validation is successful\")\n        print(f\"{'-' * 50}\")\n    info = load_yaml_file(info_file, comm)\n    sim_data = {} # Initiating a dictionary to store simulation data\n\n    try:  # Check if the file is overall sim info file and stores the simulation info\n        overall_sim_info = info[\"overall_sim_info\"]\n        sim_info = copy.deepcopy(info)\n        print(f\"{'-' * 50}\")\n        print(f\"File provided is an ouput yaml file. Continuing to read data\")\n        print(f\"{'-' * 50}\")\n\n    except KeyError:  # if the file is input info file, loads the overall_sim_info.yaml if the simulation is run already\n        if comm.rank == 0:\n            print(f\"{'-' * 50}\")\n            print(f\"File provided is an input yaml file. Checking for existing simulation results in {info['out_dir']}\")\n            print(f\"{'-' * 50}\")\n        out_yaml_file_path = f\"{info['out_dir']}/overall_sim_info.yaml\"\n\n        if os.path.isfile(out_yaml_file_path):\n            sim_info = load_yaml_file(f\"{info['out_dir']}/overall_sim_info.yaml\", comm)\n        else:\n            if comm.rank == 0:\n                print(f\"{'-' * 50}\")\n                print(f\"No existing simulation found in {info['out_dir']}\")\n                print(f\"{'-' * 50}\")\n            if run_flag == RunFlag.run:\n                if comm.rank == 0:\n                    print(f\"{'-' * 50}\")\n                    print(\"Continuing to run simulation\")\n                    print(f\"{'-' * 50}\")\n                sim = run_sim(info_file)\n                sim.run()\n                sim_info = load_yaml_file(f\"{info['out_dir']}/overall_sim_info.yaml\", comm)\n            elif run_flag == RunFlag.skip:\n                if comm.rank == 0:\n                    print(f\"{'-' * 50}\")\n                    print(\"Exiting without running sumulations\")\n                    print(f\"{'-' * 50}\")\n                return sim_data\n\n\n    # Loop through hierarchy levels\n    for hierarchy_index, hierarchy_info in enumerate(sim_info['hierarchies']):\n        hierarchy_name = hierarchy_info['name']\n        if hierarchy_name not in sim_data:\n            sim_data[hierarchy_name] = {}\n\n        # Loop through cases in the hierarchy\n        for case_index, case_info in enumerate(hierarchy_info['cases']):\n            case_name = case_info['name']\n            if case_name not in sim_data[hierarchy_name]:\n                sim_data[hierarchy_name][case_name] = {}\n\n            # Loop through experiment sets in the case\n            for exp_index, exp_info in enumerate(case_info['exp_sets']):\n                exp_set_key = f\"exp_set_{exp_index}\"\n                if exp_set_key not in sim_data[hierarchy_name][case_name]:\n                    sim_data[hierarchy_name][case_name][exp_set_key] = {}\n\n                # Loop through mesh files\n                for ii, mesh_file in enumerate(case_info['mesh_files']):\n                    refinement_level = f\"L{ii}\"\n                    if refinement_level not in sim_data[hierarchy_name][case_name][exp_set_key]:\n                        sim_data[hierarchy_name][case_name][exp_set_key][refinement_level] = {}\n\n                    # Loop through angles of attack\n                    for aoa in exp_info['aoa_list']:\n                        aoa_key = f\"aoa_{aoa}\"\n                        cl = exp_info['sim_info'][refinement_level][aoa_key].get(\"cl\")\n                        cd = exp_info['sim_info'][refinement_level][aoa_key].get(\"cd\")\n\n                        # Populate the dictionary\n                        if aoa_key not in sim_data[hierarchy_name][case_name][exp_set_key][refinement_level]:\n                            sim_data[hierarchy_name][case_name][exp_set_key][refinement_level][aoa_key] = {}\n\n                        sim_data[hierarchy_name][case_name][exp_set_key][refinement_level][aoa_key]['cl'] = cl\n                        sim_data[hierarchy_name][case_name][exp_set_key][refinement_level][aoa_key]['cd'] = cd\n\n    return sim_data\n</code></pre>"},{"location":"tutorials/inputs/","title":"Inputs","text":"<p>The <code>simulateTestCases</code> package requires the following inputs to configure and execute simulations:</p>"},{"location":"tutorials/inputs/#yaml-configuration-file","title":"YAML Configuration File","text":"<p>A YAML file is required to define the simulation parameters and organize test cases. The YAML file structure and respective descriptions are given below.</p>"},{"location":"tutorials/inputs/#input-yaml-file-structure","title":"Input YAML file Structure","text":"<p>The YAML file organizes simulation data into a structured hierarchy, enabling clear configuration of cases and experimental conditions. Below is the structure used in the YAML file:</p> <pre><code>out_dir: # str, path to the output directory\nhpc: # str, 'yes' or 'no'\nhpc_info: # dict, only needed if hpc is yes\n  cluster: # str, name of the cluste. GL for Great Lakes\n  job_name: # str, name of the job\n  nodes: # int, number of nodes\n  nproc: # int, total number of processors\n  time: #str, time in D-H:M:S format\n  account_name: # str, account name\n  email_id: # str\nhierarchies: # list, List of hierarchies\n# First hierarchy\n- name: # str, name of the hierarchy\n  cases: # list, list of cases in this hierarchy\n  # First case in the hierarchy\n  - name: # str, name of the case\n    meshes_folder_path: # str, path to the floder containing the mesh files for this case\n    mesh_files: # list, list of mesh file names\n    - # str, name of the finest mesh\n    - # str, .\n    - # str, .\n    - # str, name of the corasest mesh\n    geometry_info: # dict, dictionary of geometry info\n      chordRef: # float, reference chord length\n      areaRef: # flaot, reference area\n    solver_parameters: # dict, dictionary of solver parameters. For more information see solver parameters section\n      # ......\n    exp_sets: # list, list of dictionaries contating experimental info\n    # First experimental set in current case\n    - aoa_list: # list, list of angle of attacks(AoA) to run in with the experimental info\n      Re: # float, Reynold's number \n      mach: # float, Mach number\n      Temp: # float, Temperature in Kelvin scale\n      exp_data: # str, path to experimental data\n\n    # Second experimental set in current case\n\n  # Second case in current hierachy\n\n# Second hierarchy\n</code></pre> <p>Please note that adherence to this structure is essential; any deviation may lead to errors when running simulations. Examples of correctly formatted YAML files are provided in the <code>examples/inputs</code> folder.</p> <p>The yaml script can also be used as a starting point for generating custom YAML files.</p>"},{"location":"tutorials/inputs/#solver-parameters","title":"Solver Parameters","text":"<p>The Solver parameters is a dictionary containing options specific to the ADflow CFD solver, allowing users to customize the solver's behavior to suit their simulation needs. Detailed descriptions of these parameters and their usage can be found in the ADflow Documentation. </p> <p>If the dictionary is empty or if the default parameters are not modified, the code will use a predefined set of default solver options. These defaults are designed to provide a reliable baseline configuration for running simulations effectively without requiring manual adjustments.</p>"},{"location":"tutorials/inputs/#default-solver-parameters","title":"Default Solver Parameters:","text":"<pre><code># Print Options\n\"printIterations\": False,\n\"printAllOptions\": False,\n\"printIntro\": False,\n\"printTiming\": False,\n# I/O Parameters\n\"gridFile\": f\"grids/naca0012_L1.cgns\", # Default grid file\n\"outputDirectory\": \".\",\n\"monitorvariables\": [\"resrho\", \"resturb\", \"cl\", \"cd\", \"yplus\"],\n\"writeTecplotSurfaceSolution\": True,\n# Physics Parameters\n\"equationType\": \"RANS\",\n\"liftindex\": 3,  # z is the lift direction\n# Solver Parameters\n\"smoother\": \"DADI\",\n\"CFL\": 0.5,\n\"CFLCoarse\": 0.25,\n\"MGCycle\": \"sg\",\n\"MGStartLevel\": -1,\n\"nCyclesCoarse\": 250,\n# ANK Solver Parameters\n\"useANKSolver\": True,\n\"nsubiterturb\": 5,\n\"anksecondordswitchtol\": 1e-4,\n\"ankcoupledswitchtol\": 1e-6,\n\"ankinnerpreconits\": 2,\n\"ankouterpreconits\": 2,\n\"anklinresmax\": 0.1,\n# Termination Criteria\n\"L2Convergence\": 1e-12,\n\"L2ConvergenceCoarse\": 1e-2,\n\"nCycles\": 75000,\n</code></pre>"},{"location":"tutorials/inputs/#experimental-conditions","title":"Experimental Conditions","text":"<p>To define the problem, referred to as the AeroProblem (focused on aerodynamics), the following conditions along with the Angle of Attack(AoA) and path to the experimental data:</p> <ul> <li>Reynolds number</li> <li>Mach number</li> <li>Temperature</li> <li>Reynolds length (Computed from geometrical data)</li> </ul> <p>Other properties, such as pressure or density, will be calculated automatically based on the specified values and the governing gas laws.</p> <p>The <code>Angle of Attack (AoA)</code> is required to define the aerodynamic orientation of the flow. The <code>path to experimental data</code> can be left blank, as it will not affect the simulation. However, leaving it blank will generate a warning during the post-processing stage.</p>"},{"location":"tutorials/inputs/#location-of-mesh-files","title":"Location of Mesh Files","text":"<p>Specifying the location of the mesh files requires two inputs in every case: </p> <ul> <li><code>meshes_folder_path</code> gets the path to the folder that contains the mesh files</li> <li><code>mesh_files</code> gets the list of file names, that to be run, in the folder specified above.</li> </ul>"},{"location":"tutorials/introduction/","title":"Introduction","text":"<p>The <code>simulateTestCases</code> package is a Python-based tool designed to streamline the execution and data management of ADflow simulations. It integrates with MPhys to provide a structured framework for running aerodynamic flow simulations and organizing the resulting data in a hierarchical manner.</p> <p>This package is particularly suited for projects involving multiple configurations or test cases, ensuring that simulation results are stored and categorized systematically.</p>"},{"location":"tutorials/introduction/#key-features","title":"Key Features","text":"<ul> <li>Automates the execution of multiple ADflow simulation cases.</li> <li>Utilizes YAML configuration files for defining simulation parameters and organizing cases.</li> <li>Stores simulation data in a structured directory hierarchy for ease of access and analysis.</li> <li>Supports post-processing with methods for comparing results to experimental data and generating plots.</li> </ul>"},{"location":"tutorials/introduction/#inputs","title":"Inputs","text":"<p>The <code>simulateTestCases</code> package requires the following inputs:</p> <ol> <li> <p>YAML Configuration File:</p> <p>A YAML file specifying:</p> <ul> <li>Simulation hierarchy.</li> <li>Mesh files and solver parameters.</li> <li>Experimental conditions (e.g., Reynolds number, Mach number, and angle of attack).</li> </ul> </li> <li> <p>Output Directory:</p> <p>A directory path where the simulation results will be saved. The structure of this directory mirrors the hierarchy defined in the YAML file.</p> </li> </ol>"},{"location":"tutorials/introduction/#outputs","title":"Outputs","text":"<p>The outputs of <code>simulateTestCases</code> are stored in directories organized according to the simulation hierarchy. These include:</p> <ol> <li> <p>Simulation Data:</p> <p>Results such as C_L, C_D, and Wall Time are saved in CSV and YAML formats.</p> </li> <li> <p>Hierarchical Directory Structure:</p> <p>Output directories follow the YAML-defined hierarchy, allowing for easy navigation of results.</p> </li> <li> <p>Visualization:</p> <p>Comparison plots (e.g., experimental vs. simulated data) are generated in PNG format.</p> </li> </ol>"},{"location":"tutorials/introduction/#example-hierarchy","title":"Example Hierarchy","text":"<p>The package organizes simulation data into a clear and logical hierarchy. An example of this structure, that has been used in the tutorials is shown below:</p> <p><pre><code>Aero Problem\n    |\n    |---- 2D Clean\n    |       |\n    |       |---- NACA 0012\n    |\n    |---- 2D High-Lift\n    |       |\n    |       |---- Mc Donnell Dolugas 30P-30N\n    |\n    |---- 3D Clean\n    |       |\n    |       |---- NASA CRM clean Configuration\n    |\n    |---- 3D High-Lift\n            |\n            |---- DLR High-Lift Configuration\n</code></pre> Explanation of the Hierarchy:</p> <ol> <li> <p>Aero Problem: Categorizes the type of aerodynamic analysis, such as clean flow or high-lift studies, in 2D or 3D configurations.</p> </li> <li> <p>2D Clean: Simulations for 2D configurations without high-lift devices (e.g., NACA 0012 airfoil).</p> </li> <li> <p>2D High-Lift: Simulations for 2D configurations with high-lift devices (e.g., McDonnell Douglas 30P-30N airfoil).</p> </li> <li> <p>3D Clean: Simulations for 3D configurations without high-lift devices (e.g., NASA Common Research Model Clean Configuration).</p> </li> <li> <p>3D High-Lift: Simulations for 3D configurations with high-lift devices (e.g., DLR High-Lift Configuration).</p> </li> </ol>"},{"location":"tutorials/outputs/","title":"Outputs","text":"<p>The <code>simulateTestCases</code> package organizes simulation results into a structured directory hierarchy. This hierarchy mirrors the simulation setup defined in the YAML file.</p>"},{"location":"tutorials/outputs/#structure-of-the-output-directory","title":"Structure of the Output Directory","text":""},{"location":"tutorials/outputs/#file-types","title":"File Types","text":"<ol> <li> <p>CSV Files:</p> <ul> <li>Stored in Refinement Level directory </li> <li>Contain simulation data, including:<ul> <li>Coefficient of Lift (C<sub>L</sub>)</li> <li>Coefficient of Drag (C<sub>D</sub>)</li> <li>Wall Time</li> </ul> </li> </ul> </li> <li> <p>YAML Files:</p> <ul> <li>Two types:<ul> <li>Per-case YAML files (<code>out.yaml</code>) stored in each AoA directory.</li> <li>A summary YAML file for the entire simulation.</li> </ul> </li> </ul> </li> <li> <p>PNG Files:</p> <ul> <li>Comparison plots of experimental vs. simulated data, stored in the corresponding experimental level level directory.</li> </ul> </li> </ol> <p>This structure ensures that simulation results are easy to navigate and analyze.</p>"},{"location":"tutorials/test_cases/","title":"Test Cases and Expected Results","text":"<p>An example hierarchy is provided in the Introduction. This hierarchy serves as a reference for understanding the structure and workflow.</p> <p>When the supplied grid files and experimental data are used, the expected results for this hierarchy are outlined on this page.</p>"},{"location":"tutorials/test_cases/#hierarchy-2d-clean","title":"Hierarchy: 2D Clean","text":""},{"location":"tutorials/test_cases/#case-naca-0012","title":"Case: NACA 0012","text":"<p>Geomerty Info: <pre><code>areaRef: 1.0\nchordRef: 1.0\n</code></pre> Solver Parameters Used: <pre><code>useANKSolver: true\nnSubiterTurb: 20\nuseNKSolver: false\nNKSwitchTol: 1.0e-06\nANKCoupledSwitchTol: 0.001\nANKSecondOrdSwitchTol: 1.0e-12\nL2Convergence: 1.0e-08\nnCycles: 150000\nliftIndex: 2\n</code></pre></p>"},{"location":"tutorials/test_cases/#experimental-set-1","title":"Experimental Set: 1","text":"<p>Experimental Conditions: <pre><code>Re: 3900000.0\nmach: 0.3\nTemp: 298.0\n</code></pre></p> <p>      NACA 0012 (Exp Set: 1) Results      </p>"},{"location":"tutorials/test_cases/#hierarchy-2d-high-lift","title":"Hierarchy: 2D High-Lift","text":""},{"location":"tutorials/test_cases/#case-mc-donnell-dolugas-30p-30n","title":"Case: Mc Donnell Dolugas 30P-30N","text":"<p>Geomerty Info: <pre><code>areaRef: 1.0\nchordRef: 1.0\n</code></pre> Solver Parameters Used: <pre><code>useANKSolver: true\nnSubiterTurb: 20\nuseNKSolver: false\nNKSwitchTol: 0.0001\nANKCoupledSwitchTol: 1.0e-07\nANKSecondOrdSwitchTol: 1.0e-05\nL2Convergence: 1.0e-10\nnCycles: 150000\nliftIndex: 2\nnearWallDist: 0.01\n</code></pre></p>"},{"location":"tutorials/test_cases/#experimental-set-1_1","title":"Experimental Set: 1","text":"<p>Experimental Conditions: <pre><code>Re: 9000000.0\nmach: 0.2\nTemp: 298.0\n</code></pre></p> <p>      30P-30N (Exp Set: 1) Results      </p>"},{"location":"tutorials/test_cases/#hierarchy-3d-clean","title":"Hierarchy: 3D Clean","text":""},{"location":"tutorials/test_cases/#case-nasa-common-research-model-clean-configuration","title":"Case: NASA Common Research Model, Clean Configuration","text":"<p>Geomerty Info: <pre><code>areaRef: 191.845\nchordRef: 7.00532\n</code></pre></p> <p>Solver Parameters Used: <pre><code>useZipperMesh: True\nuseANKSolver: True\nnSubiterTurb: 5\nuseNKSolver: False\nANKCoupledSwitchTol: 1e-7\nANKSecondOrdSwitchTol: 1e-6\nL2Convergence: 1e-10\nnCycles: 150000\nliftIndex: 3\n</code></pre></p>"},{"location":"tutorials/test_cases/#experimental-set-1_2","title":"Experimental Set: 1","text":"<p>Experimental Conditions: <pre><code>Re: 5000000.0\nmach: 0.85\nTemp: 322.039\n</code></pre></p> <p>      CRM Clean (Exp Set: 1) Results      </p>"},{"location":"tutorials/test_cases/#experimental-set-2","title":"Experimental Set: 2","text":"<p>Experimental Conditions: <pre><code>Re: 5000000.0\nmach: 0.70\nTemp: 299.817\n</code></pre></p> <p>      CRM Clean (Exp Set: 2) Results      </p>"},{"location":"tutorials/test_cases/#hierarchy-3d-high-lift","title":"Hierarchy: 3D High-Lift","text":""},{"location":"tutorials/test_cases/#case-dlr-f11-high-lift-configuration","title":"Case: DLR F11, High-Lift Configuration","text":"<p>Geomerty Info: <pre><code>areaRef: 0.41913\nchordRef: 0.34709\n</code></pre> Solver Parameters Used: <pre><code>useZipperMesh: True\nuseANKSolver: True\nnSubiterTurb: 7\nuseNKSolver: False\nANKCoupledSwitchTol: 1e-7\nANKSecondOrdSwitchTol: 1e-6\nL2Convergence: 1e-10\nnCycles: 150000\nliftIndex: 3\n</code></pre></p>"},{"location":"tutorials/test_cases/#experimental-set-1_3","title":"Experimental Set: 1","text":"<p>Experimental Conditions: <pre><code>Re: 1350000.0\nmach: 0.175\nTemp: 298.15\n</code></pre> TBD</p>"},{"location":"tutorials/usage/","title":"Usage","text":"<p>The above script runs a simulation of the NACA 0012 Airfoil, and is included in the <code>examples</code> folder. </p> <p>To run the above python script:</p> <ul> <li>Copy the examples directory to a different location:</li> </ul> <pre><code>cp -r &lt;path-to-repository&gt;/examples &lt;path-to-examples-directory&gt; \n</code></pre> <ul> <li>Navigate into the directory:</li> </ul> <pre><code>cd &lt;path-to-examples-directory&gt; \n</code></pre> <ul> <li>Run the python script with a single processor:</li> </ul> <pre><code>python run_example.py --inputFile \n</code></pre> <p>or run with multiple processors</p> <pre><code>mpirun -np &lt;number of processors&gt; python run_example.py --inputFile &lt;path-to-input-yaml-file&gt;\n</code></pre> <p>Note:</p> <ul> <li>Example input yaml files to run on personal computers are stored in <code>examples/inputs</code> directory, and for Great Lakes HPC cluster, an example file is stored in <code>examples/inputs/GL</code></li> <li>Make sure to modify the file and file paths ti absolute paths in the yaml file when running in a docker container.</li> </ul> <p>Use <code>examples/inputs/naca0012_sinInfo.yaml</code> or <code>examples/inputs/GL/naca0012_sinInfo.yaml</code>(for Great Lakes) to test the package with NACA0012 airfoil.</p> <p>After execution, the following results are expected which are saved in the specified output directory.</p> <ul> <li>A copy of the input yaml file in the output directory.</li> <li><code>overall_sim_info.yaml</code> in the output directory.</li> <li><code>ADflow_Results.png</code> in each experimental level directory, that is a plot comparing C<sub>L</sub>, and C<sub>D</sub> values at all refinement levels to the expeimental data(if provided).</li> </ul> <p> </p> <ul> <li><code>ADflow_output.csv</code> in each refinement level directory, that is a file containg Angle of Attack(AoA), C<sub>L</sub>, and C<sub>D</sub> data.</li> <li><code>aoa_&lt;aoa&gt;.yaml</code> in aoa level directory, that contains the simulation information particular to that angle of attack.</li> <li>Default ADflow outputs: A tecplot file, a CGNS surface file, and a CGNS volume file.</li> </ul>"},{"location":"tutorials/usage/#example-usage","title":"Example usage","text":"<p>Here\u2019s a quick example of how to use <code>simulateTestCases</code>:</p>"},{"location":"tutorials/usage/#running-simulations","title":"Running Simulations","text":"<pre><code>from simulateTestCases.run_sim import run_sim\n\n# Initialize the runner with configuration file\nsim = run_sim('&lt;path-to-input-yaml-file&gt;')\n\n# Run the simulation series\nsim.run()\n\n# Analyze results\nsim.post_process()\n</code></pre>"},{"location":"tutorials/usage/#to-read-existing-simualtion-data-or-generate-data","title":"To read existing simualtion data or generate data","text":"<p>The function <code>get_sim_data</code> can be used to get existing simulation data that was generated after a simulation, or to generate new simulation data by passing a <code>run_flag</code>. If <code>run_flag</code> is <code>1</code>, then the function runs the simulation and outputs the data as a dictionary.</p> <p>The function provides the flexibility of using the input YAML file or  the <code>overall_sim_info.yaml</code> file that is generated and stored in the outptut directory after the completion of simulations, as inputs.</p> <pre><code>from simulateTestCases.utils import get_sim_data, RunFlag\n\n# Specify the path to the input file.\ninfo_file = 'inputs/naca0012_simInfo.yaml'\n\n# Call the function to get simulation data as a dictionary\nsim_data = get_sim_data(info_file, RunFlag.skip)\n\n# Print the dictionary\nprint(sim_data)\n</code></pre>"},{"location":"tutorials/usage/#additional-information","title":"Additional Information","text":""},{"location":"tutorials/usage/#grid-files","title":"Grid Files","text":"<p>Grids for NACA 0012 and Mc Donnell Dolugas 30P-30N are provided under <code>examples/grids</code> in the examples directory. The other grids (CRM clean, and DLR High-Lift) including Naca 0012 and 30P-30N can be found at Dropbox folder.</p>"},{"location":"tutorials/usage/#experimental-data","title":"Experimental data","text":"<p>Experimental data for NACA 0012 and Mc Donnell Dolugas 30P-30N are provided under <code>examples/exp_data</code> in the examples directory. The other dat (CRM clean, and DLR High-Lift) including Naca 0012 and 30P-30N, and their references can be found at Dropbox folder.</p>"}]}